{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"advanced/","title":"Advanced Topics","text":""},{"location":"advanced/#best-practices-and-convenient-methods","title":"Best practices and Convenient methods","text":"<p>Examples may show higher level of complexity. In this section we present best practices to implement the necessary code matching the phrase text.</p> <p>This section also offers some utility methods that you can use in your code. We encourage you to use these methods to create a shorter code with better readability. These method wraps generic operations and include the boilercode to perform these operations.</p>"},{"location":"advanced/#size","title":"Size","text":"<p>Use the python <code>len()</code> function to return how many items are in the list.</p> <p>Example</p> <p>If I have exactly one meeting on Friday send a message to mom saying that I will be free.</p> <pre><code>event_category = EventCategory.resolve_from_text(\"meeting\")\ndate_time = DateTime.resolve_from_text(\"on Friday\")\nevents = Event.find_events(\nevent_category=event_category,\ndate_time=date_time\n)\nexpr = len(events) == 1\nif expr:\nrecipient = Contact.resolve_from_text(\"mom\")\ncontent = Content.resolve_from_text(\"I will be free\")\nMessage.send_message(\nrecipient=recipient,\ncontent=content\n)\n</code></pre> <p>Oftentimes, we will use the <code>len()</code> function to verify a certain condition expression is true.</p> <p>Example</p> <p>If I didn't get any message from Louie yesterday text him to call me.</p> <pre><code>sender = Contact.resolve_from_text(\"Louie\")\ndate_time = DateTime.resolve_from_text(\"yesterday\")\nmessages = Message.find_messages(\nsender=sender,\ndate_time=date_time\n)\nexpr = len(messages) == 0\nif expr:\nrecipient = sender\ncontent = Content.resolve_from_text(\"call me\")\nMessage.send_message(\nrecipient=recipient,\ncontent=content\n)\n</code></pre>"},{"location":"advanced/#first-last-n-elements","title":"First / last <code>N</code> elements","text":"<p>We provide a convenient method to return the first (or last) <code>N</code> elements (defaults to 1 if not specified).</p> <p>Prefer using this method over Pyton slicing, if you are familiar with it.</p> <pre><code>```py\nutils.first(items: List[Entity], n: int): List[Entity]\n```\n</code></pre> <p>Parameters:</p> <pre><code>items: `List[Entity]`\n    A list of items.\n\nn: `int`\n    Number of items to fetch in the list.\n</code></pre> <p>Example</p> <p>Delete the last 2 messages from Henry.</p> <pre><code>sender = Contact.resolve_from_text(\"Henry\")\nmessages = Message.get_message(sender=sender)\nmessages = utils.last(messages, 2)\nMessage.delete_messages(messages=messages)\n</code></pre>"},{"location":"advanced/#all","title":"All","text":"<p>Return whether every element is True or equivalent (e.g. non-zero or non-empty).</p> <p>Returns False in case there is at least one element within a series or along a Dataframe axis that is True or equivalent.</p> <pre><code>```py\nutils.all(items: List[Entity], **kwargs)\n```\n</code></pre> <p>Parameters:</p> <pre><code>items: `List[Entity]`\n    A list to perform the test on.\n\n**kwargs:\n    Arguments list according to the action API `find_` function arguments.\n</code></pre> <p>Example</p> <p>Will it rain every day this weekend?</p> <pre><code># find the weather forecasts for every day this weekend\ndate_time = DateTime.resolve_from_text(\"this weekend\")\nweather_forecasts = Weather.find_weather_forecasts(\ndate_time=date_time\n)\n# arguments to test for all items in the list\nweather_attr = WeatherAttribute.resolve_from_text(\"rain\")\nutils.all(weather_forecasts, weather_attr=weather_attr)\n</code></pre>"},{"location":"advanced/#sort","title":"<code>sort</code>","text":"<p>Sort by a specific type.</p> <p>Example</p> <p>Get directions to the nearest pharmacy.</p> <pre><code>destinations = Location.resolve_from_text(\"pharmacy\")\ndestinations = utils.sort(destinations, \"nearest\")\ndestination = utils.first(destinations)\nnavigation_directions = Navigation.find_directions(\ndestination=destination\n)\nResponder.respond(response=navigation_directions)\n</code></pre>"},{"location":"advanced/#most","title":"<code>most</code>","text":"<p>Return True whether the majority of items in a list are matching a given criteria.</p> <pre><code>```py\nutils.most(items: List[Entity], **kwargs): List[Entity]\n```\n</code></pre> <p>Parameters:</p> <pre><code>items: `List[Entity]`\n    A list of items.\n\n**kwargs:\n    Arguments list according to the action API `find_` function arguments.\n</code></pre> <p>Example</p> <p>Is it going to be mostly rainy over this weekend?</p> <pre><code>weather_attribute = WeatherAttribute.resolve_from_text(\"rainy\")\ndate_time = DateTime.resolve_from_text(\"this weekend\")\nweather_forecasts = Weather.find_weather_forecasts(\ndate_time=date_time\n)\nresult = utils.most(\nweather_forecasts,\nweather_attribute=weather_attribute\n)\nResponder.respond(response=result)\n</code></pre>"},{"location":"advanced/#filter","title":"<code>filter</code>","text":"<p>Some user requests will require additional filtering on the actions results.</p> <p>This method subsets the data according to specified data types resolved from the text.</p> <pre><code>```py\nutils.filter(items: List[Entity], **kwargs): List[Entity]\n```\n</code></pre> <p>Parameters:</p> <pre><code>items: `List[Entity]`\n    A list of items.\n\n **kwargs:\n    Arguments list according to the action API `find_` function arguments.\n</code></pre> <p>Example</p> <p>If the road to my office is icy then text John to expect traffic.</p> <pre><code>\n\n```py\ndestination = Location.resolve_from_text(\"my office\")\nnav_road_conditions = NavigationRoadConditions.resolve_from_text(\"icy\")\nnavigation_directions = Navigation.find_directions(\n    destination=destination,\n    nav_road_conditions=nav_road_conditions\n)\nexpr = len(navigation_directions) &gt; 0\n\nif expr:\n    recipient = Contact.resolve_from_text(\"John\")\n    content = Content.resolve_from_text(\"expect traffic\")\n    Message.send_message(\n        recipient=recipient,\n        content=content\n    )\n```\n</code></pre> <p>We first query for directions to a specific destination (\"the office\") and show it to the user.</p> <p>Then, we need to filter the results for any matches to the requested criteria (in this example: road conditions are \"icy\").</p>"},{"location":"advanced/#map","title":"<code>map</code>","text":"<p>This method applies a function returns a value to every item of a list according to a textual description.</p> <p>The <code>map</code> function is usually used to extract values on a fetched list of items.</p> <pre><code>```py\nutils.map(items: List[Entity], text: str): List[Entity]\n```\n</code></pre> <p>Parameters:</p> <pre><code>items: `List[Entity]`\n    A list of items.\n\ntext: `str`\n    Text value to map the list items according to.\n</code></pre> <p>Example</p> <p>Email all attendees on the 9am meeting that I am running late.</p> <pre><code>date_time = DateTime.resolve_from_text(\"9am\")\nevents = Event.find_events(date_time=date_time)\nrecipients = utils.map(events, \"all attendees\")\nfor recipient in recipients:\ncontent = Content.resolve_from_text(\"I am running late\")\nMessage.send_message(\nrecipient=recipient,\ncontent=content\n)\n</code></pre>"},{"location":"advanced/#exceptions-and-errors","title":"Exceptions and errors","text":"<p>Sometimes users make requests that cannot be fulfilled, like when requesting for a non existant date (Feb 30th) or when one of the requests should not produce any results (\"Delete all emails from Gavin\" where Gavin never sent an email).</p> <p>When writing code, you can assume no failures should happen due to the user provided inputs and call the APIs without worrying for any exceptions.</p> <p>The system deals with such failures and operates a recovery mechanism. The recovery mechanism tries to recover from all these exceptions by describing the problem to the user and prompting a corrected input or dismissal of the user utterance. This is out of scope of this work and you should not bother youself with details about it</p>"},{"location":"exercise_writing_tests/","title":"Exercise writing tests","text":"<p>Let's test your knowledge of the Tests tutorial. We will provide you with a user command and you will write the test to match it.</p>"},{"location":"exercise_writing_tests/#exercise-1","title":"Exercise 1","text":"<p>Write a test for the following user command:</p> <p>Check the weather for the 4th of July and send a text to Grandpa that he should come over</p> Hint <p>Required API references for this exercise:</p> <ul> <li>Message</li> <li>Weather</li> </ul> Solution <pre><code>from providers.data_model import DataModel\nfrom entities.generic import Contact, Content, DateTime\nfrom entities.weather import WeatherForecastEntity\nfrom entities.message import MessageEntity\ndata_model = DataModel(reset=True)\n# seed data for the 1st command\ndata_date_time = DateTime(text=\"4th of July\", value=datettime.now() + timedelta(days=1))\ndata_model.append(data_date_time)\ndata_model.append(\nWeatherForecastEntity(date_time=data_date_time)\n)\n# seed the data for the 2nd command\ndata_recipient = Contact(text=\"Grandpa\")\ndata_model.append(data_recipient)\ndata_content = Content(text=\"he should come over\")\ndata_model.append(data_content)\n# test assertions for the 1st command\ndata_weather_forecasts_list = data_model.get_data(WeatherForecast)\nassert len(data_weather_forecasts_list) == 1\ndata_weather_forecasts = data_weather_forecasts_list[0]\nassert test_equal(data_weather_forecasts[0].data.get(\"date_time\"), data_date_time)\n# test assertions for the 2nd command\ndata_messages = data_model.get_data(MessageEntity)\nassert len(data_messages) == 1\ndata_message = data_messages[0]\nassert test_equal(data_message.data.get(\"recipient\"), data_recipient)\nassert test_equal(data_message.data.get(\"content\"), data_content)\n</code></pre>"},{"location":"exercise_writing_tests/#exercise-2","title":"Exercise 2","text":"<p>Write a test for the following user command:</p> <p>If it rains tomorrow message dad that I will be running late.</p> Hint <p>Required API references for this exercise:</p> <ul> <li>Message</li> <li>Weather</li> </ul> Solution <pre><code>from providers.data_model import DataModel\nfrom entities.generic import Contact, Content, DateTime\nfrom entities.weather import WeatherAttribute, WeatherForecastEntity\ndata_model = DataModel(reset=True)\n# seed data for the condition query\ndata_date_time_tomorrow = DateTime(text=\"tomorrow\", value=datettime.now() + timedelta(days=1))\ndata_model.append(data_date_time_tomorrow)\ndata_weather_attribute = WeatherAttribute(text=\"rains\")\ndata_model.append(data_weather_attribute)\ndata_model.append(\nWeatherForecastEntity(\ndate_time=data_date_time_tomorrow,\nweather_attribute=data_weather_attribute\n)\n)\n# seed the data for the executed command\ndata_recipient = Contact(text=\"dad\")\ndata_model.append(data_recipient)\ndata_content = Content(text=\"I will be running late\")\ndata_model.append(data_content)\n# test assertions\ndata_messages = data_model.get_data(MessageEntity)\nassert len(data_messages) == 1\ndata_message = data_messages[0]\nassert test_equal(data_message.data.get(\"recipient\"), data_recipient)\nassert test_equal(data_message.data.get(\"content\"), data_content)\n</code></pre> <p>Additional test for the case the condition is not met:</p> <pre><code>from providers.data_model import DataModel\nfrom entities.generic import Contact, Content, DateTime\nfrom entities.weather import WeatherAttribute, WeatherForecastEntity\ndata_model = DataModel(reset=True)\n# seed data for the condition query\ndata_date_time_tomorrow = DateTime(text=\"tomorrow\", value=datettime.now() + timedelta(days=1))\ndata_model.append(data_date_time_tomorrow)\ndata_weather_attribute = WeatherAttribute(text=\"not rain\")\ndata_model.append(data_weather_attribute)\ndata_model.append(\nWeatherForecast(\ndate_time=data_date_time_tomorrow,\nweather_attribute=data_weather_attribute\n)\n)\n# seed the data for the executed command\ndata_recipient = Contact(text=\"dad\")\ndata_model.append(data_recipient)\ndata_content = Content(text=\"I will be running late\")\ndata_model.append(data_content)\n# test assertions\ndata_messages = data_model.get_data(MessageEntity)\nassert len(data_messages) == 0\n</code></pre>"},{"location":"exercise_writing_tests/#exercise-3","title":"Exercise 3","text":"<p>Write a test for the following user command:</p> <p>Text Stacy and Amanda that dinner will be ready in one hour.</p> Hint <p>Required API references for this exercise:</p> <ul> <li>Message</li> </ul> Solution <pre><code>from providers.data_model import DataModel\nfrom entities.generic import Contact, Conten\nfrom entities.message import MessageEntity\n# test data\ndata_model = DataModel(reset=True)\ndata_contact_stacy = Contact(text=\"Stacy\")\ndata_model.append(data_contact_stacy)\ndata_contact_amanda = Contact(text=\"Amanda\")\ndata_model.append(data_contact_amanda)\ndata_content = Content(\ntext=\"dinner will be ready in one hour\"\n)\ndata_model.append(data_content)\n# assertions\ndata_messages = data_model.get_data(MessageEntity)\nassert len(data_messages) == 2\nassert test_equal(data_messages[0].data.get(\"recipient\"), data_contact_stacy)\nassert test_equal(data_messages[0].data.get(\"content\"), data_content)\nassert test_equal(data_messages[1].data.get(\"recipient\"), data_contact_amanda)\nassert test_equal(data_messages[1].data.get(\"content\"), data_content)\n</code></pre>"},{"location":"exercise_writing_tests/#exercise-4","title":"Exercise 4","text":"<p>Write a test for the following user command:</p> <p>Send Tyler a text saying hi and send one to Susan too.</p> Hint <p>Required API references for this exercise:</p> <ul> <li>Message</li> </ul> Solution <pre><code>from providers.data_model import DataModel\nfrom entities.generic import Contact, Content\nfrom entities.message import MessageEntity\n# test data\ndata_model = DataModel(reset=True)\ndata_contact1 = Contact(text=\"Tyler\")\ndata_model.append(data_contact1)\ndata_contact2 = Contact(text=\"Susan\")\ndata_model.append(data_contact2)\ndata_content = Content(text=\"hi\")\ndata_model.append(data_content)\n# test assertions\ndata_messages = data_model.get_response(MessageEntity)\nassert len(data_messages) == 2\ndata_message1 = data_messages[0]\nassert test_equal(data_message1.data.get(\"recipient\"), data_contact1)\nassert test_equal(data_message1.data.get(\"content\"), data_content)\ndata_message2 = data_messages[1]\nassert test_equal(data_message2.data.get(\"recipient\"), data_contact2)\nassert test_equal(data_message2.data.get(\"content\"), data_content)\n</code></pre>"},{"location":"exercises/","title":"Exercises","text":"<p>Follow the quick Get Started tutorial and the conding convention we present there and try writing a code for given user (complex) commands challenges.</p>"},{"location":"exercises/#exercise-1","title":"Exercise 1","text":"<p>Try to write code for the following user command. This time, we will provide a solution to this exercise.</p> <p>What will the weather be in two hours, and remind me then to go running.</p> Solution <pre><code>date_time = DateTime.resolve_from_text(\"in two hours\")\nweather_forecast = Weather.find_weather_forecasts(\ndate_time=date_time\n)\nResponder.respond(response=weather_forecast)\nperson_reminded = Contact.resolve_from_text(\"me\")\ncontent = Content.resolve_from_text(\"go running\")\nreminder = Reminders.create_reminder(\nperson_reminded=person_reminded, \ndate_time=date_time\ncontent=content, \n)\n</code></pre>"},{"location":"exercises/#exercise-2","title":"Exercise 2","text":"<p>Try to write code for the following user command:</p> <p>If there's a concert in the park next month, remind me next week to check for discounted tickets.</p>"},{"location":"exercises/#exercise-3","title":"Exercise 3","text":"<p>Write code for the following user command:</p> <p>Read me my new emails in my mailbox and archive them once they are read.</p>"},{"location":"exercises/#exercise-4","title":"Exercise 4","text":"<p>I need you to give me directions to a place where I can rent the cheapest tux in town, and then directions from there to the wedding reception event I have scheduled.</p>"},{"location":"get_started/","title":"Getting started","text":"<p>Let's learn by example.</p> <p>Throughout this tutorial, we\u2019ll walk you through the creation of a basic Python code for given virtual agent user commands.</p> <p>We collected user commands for a virtual assistance (like Siri or Alexa). The virtual assistant offers help in navigation, weather forecasts, messaging, reminders, shopping and more. The goal of this project is to match user commands in English to a valid Python code.</p> <p>We\u2019ll assume you have a basic experience with Python already.</p>"},{"location":"get_started/#simple-commands","title":"Simple commands","text":"<p>Simple commands express a single action that the virtual assistant is expected to perform.</p>"},{"location":"get_started/#simple-command-example","title":"Simple command example","text":"<p>Let's start by writing a code for a simple user command:</p> <p>Get directions from Disneyland to my house.</p> <p>To match this user command we need to map it with the <code>Navigation.find_directions(origin: Optional[Location], destination: Location)</code> function in the Navigation API.</p> <pre><code>origin = Location.resolve_from_text(\"Disneyland\")\ndestination = Location.resolve_from_text(\"my house\")\nnavigation_directions = Navigation.find_directions(\norigin=origin,\ndestination=destination\n)\nResponder.respond(response=navigation_directions)\n</code></pre> <p><code>Navigation.find_directions</code> is taking an origin <code>Location</code> and a destination <code>Location</code> as its parameters.</p> <p>We first create the origin <code>Location</code> object. We name it according to the argument name <code>origin</code>. A text is usually mapped to a variable using the <code>resolve_from_text()</code> function.</p> <p>Likewise, we then create the destination <code>Location</code> object and name it with the argument name <code>destination</code>.</p> <p>Next, we plug the <code>origin</code> and <code>destination</code> parameters into the <code>Navigation.find_directions</code> function call. This function will return a list of navigation directions.</p> <p>Last, we report back the result to the user using the <code>Responder.respond(response: Entity|List[Entity])</code> API. As the <code>response</code> we set the <code>navigation_directions</code> result from the previous step.</p>"},{"location":"get_started/#another-simple-command-example","title":"Another simple command example","text":"<p>Another simple user command:</p> <p>Text Karen that I will be late.</p> <p>To match this user command we need to map it with the <code>Messages.send_message(recipient: Contact, content: Content)</code> API in the Messaging API.</p> <pre><code>recipient = Contact.resolve_from_text(\"Karen\")\ncontent = Content.resolve_from_text(\"I will be late\")\nMessages.send_message(\nrecipient=recipient,\ncontent=content\n)\n</code></pre> <p>We first create the <code>Contact</code> object and name it according to the argument name <code>recipient</code>.</p> <p>Similarly, we create the <code>Content</code> object and name it <code>content</code>.</p> <p>Next, we plug the <code>recipient</code> and <code>content</code> parameters into the <code>Messages.send_message</code> function call to call the function with its arguments.</p>"},{"location":"get_started/#complex-commands","title":"Complex commands","text":"<p>Complex commands can express multiple simple commands together like in sequences or conditions. Alterntaively, complex can call a simple commands multiple times like in loops.</p> <p>Let's see some examples for complex commands.</p>"},{"location":"get_started/#complex-command-example","title":"Complex command example","text":"<p>Complex user command:</p> <p>Get directions from Disneyland to my house and text them to Robert.</p> <p>We already went over the first part of the command (\"Get directions from Disneyland to my house\").</p> <pre><code>origin = Location.resolve_from_text(\"Disneyland\")\ndetination = Location.resolve_from_text(\"my house\")\nnavigation_directions = Navigation.find_directions(\norigin=origin,\ndestination=destination\n)\n</code></pre> <p>Let's see the other part and put the code together. To match \"text them to Robert\" user command we need to map it with the <code>Messages.send_message</code> API.</p> <pre><code>recipient = Contact.resolve_from_text(\"Robert\")\ncontent = Content.resolve_from_entity(navigation_directions)\nMessages.send_message(\nrecipient=recipient,\ncontent=content\n)\n</code></pre> <p>We create the <code>Contact</code> object and name it <code>recipient</code>.</p> <p>Now we need to create the <code>Content</code> object. Notice that in this example, the content of the message in this example is the navigation directions list we got on the previous step. Therefore, we use the utility function <code>Content.resolve_from_entity()</code> to cast the <code>navigation_direction</code> entity to a <code>Content</code> entity.</p> <p>Last, we call the <code>Messages.send_message</code> function with its arguments.</p> <p>The final code should look like this:</p> <pre><code>origin = Location.resolve_from_text(\"Disneyland\")\ndestination = Location.resolve_from_text(\"my house\")\nnavigation_direction = Navigation.find_directions(\norigin=origin,\ndestination=destination\n)\nrecipient = Location.resolve_from_text(\"Robert\")\ncontent = Content.resolve_from_entity(navigation_direction)\nmessage = Messages.send_message(\nrecipient=recipient,\ncontent=content\n)\n</code></pre>"},{"location":"get_started/#another-complex-command-example","title":"Another complex command example","text":"<p>Let's see another complex user command:</p> <p>Remind me to bring an umbrella if it rains tomorrow.</p> <p>The first part of the command: \"Remind me to bring an umbrella\" is conditioned by the second part of the sentence \"if it rains tomorrow\".</p> <p>Conditions are another building blocks of complex commands.</p> <p>First, we get the weather forecasts by using the <code>Weather.find_weather_forecasts(date_time: Optional[DateTime], weather_attribute: Optional[WeatherAttribute])</code> in the Weather API.</p> <pre><code>date_time = DateTime.resolve_from_text(\"tomorrow\")\nweather_attribute = WeatherAttribute.resolve_from_text(\"rains\")\nweather_forecasts = Weather.find_weather_forecasts(\ndate_time=date_time,\nweather_attribute=weather_attribute\n)\n</code></pre> <p>Note</p> <p>This API takes additional optional arguments, like a location, which we did not include in this example. In that case, the API assumes default values for the unspecified arguments (like the current location). Don't bother yourself with it and use only what is specified in the example.</p> <p>Then, we check for the truthness of the condition expression. It will be valid if the <code>Weather.find_weather_forecasts</code> returned any result. This function return a list of weather forecases that match the <code>DateTime</code> and <code>WeatherAttribute</code>.</p> <pre><code>expr = len(list(weather_forecasts)) &gt; 0\nif expr:\n</code></pre> <p>The condition body should include the \"Remind me to bring an umbrella\" command.</p> <pre><code>person_reminded = Contact.resolve_from_text(\"me\")\ncontent = Content.resolve_from_text(\"Bring an umbrella\").\nReminder.create_reminder(\nperson_reminded=person_reminded,\ncontent=content\n)\n</code></pre> <p>We follow the <code>Reminder.create_reminder(person_reminded: Optional[Contact], content: Content)</code> API spec.</p> <p>Note</p> <p>Notice that in the <code>content</code> object we omit the word \"to\" and keep the content that should appear in the reminder (\"bring an umbrella\").</p> <p>Putting everything together:</p> <pre><code>date_time = DateTime.resolve_from_text(\"tomorrow\")\nweather_attribute = WeatherAttribute.resolve_from_text(\"rains\")\nweather_forecasts = Weather.find_weather_forecasts(\ndate_time=date_time,\nweather_attribute=weather_attribute\n)\nexpr = len(weather_forecasts) &gt; 0\nif expr:\nperson_reminded = Contact.resolve_from_text(\"me\")\ncontent = Content.resolve_from_text(\"bring an umbrella\")\nreminder = Reminders.create_reminder(\nperson_reminded=person_reminded,\ncontent=content\n)\n</code></pre>"},{"location":"get_started/#yet-another-complex-command-example","title":"Yet another complex command example","text":"<p>Let's see one more complex user command:</p> <p>What is the weather in Paris and London?</p> <p>We will execute this command in a loop iterating over \"Paris\" and \"London\", althought it can be executed it in a sequence like previous commands.</p> <p>Weather forecasts are returned in the <code>Weather.find_weather_forecasts(location: Optional[Location])</code></p> <p>We are required to report back to the user every result. This is done using <code>Responder.respond(response: Entity | List[Entity])</code>. Since we are looping, we collect all responses in the response <code>list</code> and pass it to the <code>Responder.respond()</code> function.</p> <pre><code>location1 = Location.resolve_from_text(\"Paris\")\nlocation2 = Location.resolve_from_text(\"London\")\nresponse = []\nfor location in [location1, location2]:\nweather_forecasts = Weather.find_weather_forecasts(location=location)\nresponse.append(weather_forecasts)\nResponder.respond(response=response)\n</code></pre>"},{"location":"get_started/#last-complex-command-example","title":"Last complex command example","text":"<p>We'll finish this part of the tutorial with one last complex user command:</p> <p>Show me the traffic to each Whole Food branch in a 10 miles radius.</p> <p>Traffic information is acquired using the <code>Navigation.find_traffic_info(destination: Optional[Location])</code> API in the Navigation API.</p> <pre><code>destinations = Location.resolve_many_from_text(\"each Whole Food branch\")\ndestinations = utils.filter()\nresponse = []\nfor destination in destinations:\ntraffic_info = Navigation.find_traffic_info(destination=destination)\nif traffic_info:\nresponse.append(traffic_info)\nResponder.respond(response=response)\n</code></pre> <p>While in previous examples we saw specific location names (e.g. Disneyland, my house), in this example we are looking at a group of locations. The function <code>Location.resolve_many_from_text</code> should be used to return a list of <code>Location</code> objects (like in this case) according to the text argument it is called with.</p> <p>We get a list of <code>Location</code> using <code>Location.resolve_from_text</code>. The full text describing the location should be provided to it: <code>each Whole Food branch in a 10 miles radius</code>.</p> <p>Next, we loop over the list of <code>Location</code> from the previous step and find the Navigation traffic information using the <code>Navigation.find_traffic_info()</code>.</p> <p>We append each traffic info result to a <code>response</code> list and when the loop finishes we call the <code>Responder.respose()</code> with this list.</p>"},{"location":"tests/","title":"Testing","text":"<p>We collected user commands for a virtual assistance (like Siri or Alexa). The virtual assistant offers help in navigation, weather forecasts, messaging, reminders, shopping and more. The goal of this project is to match user commands in English to a valid Python code.</p> <p>This section will walk you through the process of testing the generated code.</p>"},{"location":"tests/#evaluating-text-to-code-models","title":"Evaluating text to code models","text":"<p>Text to code models are machine learning models that are trained to generate code from natural language descriptions. One way to evaluate a text to code model is by comparing the generated code to a gold standard or reference implementation, also known as denotation, to ensure that the generated code is equivalent in functionality and performance.</p> <p>Evaluating generated code is an important step in the process of using code generation tools. Generated code should be thoroughly tested and reviewed to ensure that it meets the desired specifications and functions correctly, without errors or bugs. This can be tested through manual testing or by using automated testing tools.</p> <p>We evluate the quality of the text to code model by testing the generated code using unit tests and integration tests. The tests are used to test the generated code in isolation. We test each generated code snippet in isolation to ensure that it functions correctly in the context of the frameworks API.</p>"},{"location":"tests/#api-tests","title":"API tests","text":"<p>We release a set of API libraries that simulate the functionality of the APIs that are used in the generated code. These libraries are used to test the generated code in isolation. The API libraries and their spec are listed in the API reference page.</p> <p>The API tests are located in the <code>tests</code> directory.</p>"},{"location":"tests/#getting-started-with-api-tests","title":"Getting started with API tests","text":"<p>Throughout this tutorial we will walk you through the creation of a basic Python code for given virtual agent user commands.</p> <p>Note</p> <p>Without the generated code we are nto able to run the tests. Yet, we can still write tham in isolation of the generated code. The tests are dependant from the actual generated code.</p>"},{"location":"tests/#prerequisites","title":"Prerequisites","text":"<ul> <li>Basic knowledge of Python.</li> <li>Get yourself farmiliar with the API Getting started and API reference pages.</li> </ul> <p>That's it. We are ready to start writing tests.</p>"},{"location":"tests/#writing-tests","title":"Writing tests","text":"<p>Let's learn by example.</p>"},{"location":"tests/#simple-command","title":"Simple command","text":"<p>Simple commands express a single action that the virtual assistant is expected to perform.</p> <p>Text Karen that I will be late.</p> <p>This command should return an object of text message. The generated code for this example can be found in the Getting started page.</p> <p>Every test should start by seeding the data. In this case we need to seed the data with the <code>recipient</code> and <code>content</code> attributes. We expect the generated code to create a <code>MessageEntity</code> object with the <code>recipient</code> and <code>message</code> attributes.</p> <pre><code>from providers.data_model import DataModel\nfrom entities.generic import Contact, Content\nfrom entities.message import MessageEntity\ndata_model = DataModel(reset=True)\ndata_recipient = Contact(text=\"Karen\")\ndata_model.append(data_recipient)\ndata_content = Content(text=\"I will be late\")\ndata_model.append(data_content)\n</code></pre> <p>We start by importing the necessary classes. Don't bother yourself too much with it. These are just the classes that will be used to seed the data and the test itself so you can always go back and add them as you write the test.</p> <p>Next we are creating a <code>DataModel</code> object and setting the <code>reset</code> attribute to <code>True</code>. This will reset the data model and remove all the data that was seeded before.</p> <p>We then create a <code>Contact</code> object and set the <code>text</code> attribute to the contact name. We repeat the same process for the <code>Content</code> object with the expected message content.</p> <p>We can now write the test.</p> <pre><code>data_messages = data_model.get_data(MessageEntity)\nassert len(data_messages) == 1\ndata_message = data_messages[0]\nassert test_equal(data_message[0].data.get(\"recipient\"), data_recipient)\nassert test_equal(data_message[0].data.get(\"content\"), data_content)\n</code></pre> <p>We start by getting the data from the data model. We use the <code>get_data</code> method to get the data with the <code>MessageEntity</code> type. We then assert that the data list has only one element. We expect our generated code to create only one <code>MessageEntity</code> object.</p> <p>We then get the first element from the data list and assert that the <code>recipient</code> attribute is set to the <code>Contact</code> object that we seeded before. We also assert that the <code>message</code> attribute is set to the <code>Content</code> object that we seeded before. To assert that the attributes are set to the correct objects we use the <code>test_equal</code> function. This function is used to compare two objects.</p> <p>That's it. We have written our first test.</p>"},{"location":"tests/#another-simple-command","title":"Another simple command","text":"<p>Let's look at another simple command.</p> <p>Get directions from Disneyland to my house.</p> <p>This command should return a list of navigation directions. The generated code for this example can be found in the Getting started page.</p> <p>We remind you that every test should start by seeding the data. In this case we need to seed the data with the <code>origin</code> and <code>destination</code> locations. We can do this by creating a <code>Location</code> object and setting the <code>text</code> attribute to the location name.</p> <pre><code>from providers.data_model import DataModel\nfrom entities.generic import Location\nfrom entities.navigation import NavigationDirectionEntity\ndata_model = DataModel(reset=True)\ndata_origin = Location(text=\"Disneyland\")\ndata_model.append(data_origin)\ndata_destination = Location(text=\"my house\")\ndata_model.append(data_destination)\ndata_model.append(\nNavigationDirectionEntity(origin=data_origin, destination=data_destination)\n)\ndata_model.append(\nNavigationDirectionEntity(origin=data_origin, destination=data_destination)\n)\n</code></pre> <p>We start with creating a <code>DataModel</code> object and setting the <code>reset</code> attribute to <code>True</code>.</p> <p>We then create two <code>Location</code> objects and set the <code>text</code> attribute to the location name. We then append the objects to the data model. In this case we see the data with the origin <code>Location</code> object that will be set to <code>Disneyland</code>, and the data with the destination <code>Location</code> is set to <code>my house</code>.</p> <p>Next we append two <code>NavigationDirectionEntity</code> object to the data model. We choose 2 as an arbitrary number, like there can be 2 possible directions to get from the origin to the destination. These objects will be used to test the generated code.</p> <p>We can now write the test.</p> <pre><code>data_navigation_directions_list = data_model.get_data(NavigationDirectionEntity)\nassert len(data_navigation_directions_list) == 1\ndata_navigation_directions = data_navigation_directions_list[0]\nassert len(data_navigation_directions) == 2\nassert test_equal(data_navigation_directions[0].data.get(\"origin\"), data_origin)\nassert test_equal(data_navigation_directions[0].data.get(\"destination\"), data_destination)\nassert test_equal(data_navigation_directions[1].data.get(\"origin\"), data_origin)\nassert test_equal(data_navigation_directions[1].data.get(\"destination\"), data_destination)\n</code></pre> <p>We start by getting the data from the data model. We get the data with the <code>NavigationDirectionEntity</code> object. We then assert that the length of the data is equal to 1. This means that we have one list of <code>NavigationDirectionEntity</code> objects in the data model, and that our generated code is matching the text description and created only a single <code>NavigationDirectionEntity</code> list of objects.</p> <p>We then get the first <code>NavigationDirectionEntity</code> element from the data model. In the case of navigation direction, this is expected to be a list of <code>NavigationDirectionEntity</code> objects. We assert that this list length is equal to 2. This means that we have two <code>NavigationDirectionEntity</code> objects in the list.</p> <p>We then assert that the <code>origin</code> attribute of each of the <code>NavigationDirectionEntity</code> objects is equal to the <code>data_origin</code> object. We also assert that the <code>destination</code> attribute of each of the <code>NavigationDirectionEntity</code> object is equal to the <code>data_destination</code> object.</p> <p>Note</p> <p>The <code>NavigationDirectionEntity</code> object is an object that we created to seed the test data for the generated code. It is not what is returned in <code>data_model.get_data(NavigationDirectionEntity)</code>. The objects that are returned are expected to be created in the generated code.</p> <p>Voila! We have written our second test.</p>"},{"location":"tests/#sequence-complex-command","title":"Sequence complex command","text":"<p>Complex commands allow you to combine multiple simple commands into a single request for your virtual assistant. These commands can be performed in a specific sequence, include conditional statements, or be executed multiple times.</p> <p>Now let's look at a complex command where commands are executed in a sequence.</p> <p>Get directions from Disneyland to my house and text Karen that I will be late.</p> <p>This command should return a list of navigation directions and a text message. The generated code for this example can be found in the Getting started page.</p> <p>We remind you that every test should start by seeding the data. In this case we need to seed the data with the <code>origin</code> and <code>destination</code> locations. We also need to seed the data with the <code>Contact</code> and <code>Content</code> objects.</p> <pre><code>from providers.data_model import DataModel\nfrom entities.generic import Contact, Content, Location\nfrom entities.navigation import NavigationDirectionEntity\ndata_model = DataModel(reset=True)\n# seed data for the 1st command\ndata_origin = Location(text=\"Disneyland\")\ndata_model.append(data_origin)\ndata_destination = Location(text=\"my house\")\ndata_model.append(data_destination)\ndata_model.append(\nNavigationDirectionEntity(origin=data_origin, destination=data_destination)\n)\ndata_model.append(\nNavigationDirectionEntity(origin=data_origin, destination=data_destination)\n)\n# seed data for the 2nd command\ndata_recipient = Contact(text=\"Karen\")\ndata_model.append(data_recipient)\ndata_content = Content(text=\"I will be late\")\ndata_model.append(data_content)\n</code></pre> <p>Like before, we start with creating a <code>DataModel</code> object and setting the <code>reset</code> attribute to <code>True</code>.</p> <p>We start by seeding the data for the first command. We create a <code>Location</code> origin object and set the <code>text</code> attribute to the location name. We then append the object to the data model. We do the same for the destination location. We also append two <code>NavigationDirectionEntity</code> object to the data model. We choose 2 as an arbitrary number, like there can be 2 possible directions to get from the origin to the destination. These objects will be used to test the generated code.</p> <p>We then seed the data for the second command. We can do this by creating a <code>Contact</code> object and setting the <code>text</code> attribute to the contact name. We repeat the same process for the <code>Content</code> object with the expected message content. We then append the objects to the data model.</p> <p>We can now write our complex command test.</p> <pre><code>data_navigation_directions_list = data_model.get_data(NavigationDirectionEntity)\nassert len(data_navigation_directions_list) == 1\ndata_navigation_directions = data_navigation_directions_list[0]\nassert len(data_navigation_directions) == 2\nassert test_equal(data_navigation_directions[0].data.get(\"origin\"), data_origin)\nassert test_equal(data_navigation_directions[0].data.get(\"destination\"), data_destination)\nassert test_equal(data_navigation_directions[1].data.get(\"origin\"), data_origin)\nassert test_equal(data_navigation_directions[1].data.get(\"destination\"), data_destination)\ndata_messages = data_model.get_data(MessageEntity)\nassert len(data_messages) == 1\ndata_message = data_messages[0]\nassert test_equal(data_message.data.get(\"recipient\"), data_recipient)\nassert test_equal(data_message.data.get(\"content\"), data_content)\n</code></pre> <p>We test the expected generated objects for the first command. We then test the expected generated objects for the second command. Nothing new here.</p> <p>Congratulations! You have now written your first test for a complex command.</p>"},{"location":"tests/#conditional-complex-command","title":"Conditional complex command","text":"<p>Conditional complex commands allow you to condition the execution of one command by checking the result of another command. This is useful when you want to execute a command only if a previous command was successful (or not).</p> <p>Now let's look at a conditional complex command.</p> <p>Remind me to bring an umbrella if it rains tomorrow.</p> <p>Conditional complex commands are a bit more complex to test. We need to test two scenarios: the condition is met and the condition is not met. We will start by testing the scenario where the condition is met.</p> <p>This command should return a reminder only if the weather is rainy. The generated code for this example can be found in the Getting started page.</p> <p>Like before, we start by seeding the data. In this case we need to seed the data with the <code>Content</code> of the reminder, the <code>Contact</code> or the person being reminded, the <code>WeatherAttribute</code> and the <code>DateTime</code> objects for the weather forecasts.</p> <pre><code>from providers.data_model import DataModel\nfrom entities.generic import Contact, Content, DateTime\nfrom entities.reminder import ReminderEntity\nfrom entities.weather import WeatherAttribute, WeatherForecastEntity\ndata_model = DataModel(reset=True)\n# seed data for the 1st command\ndata_person_reminded = Contact(text=\"me\")\ndata_model.append(data_person_reminded)\ndata_content = Content(text=\"bring an umbrella\")\ndata_model.append(data_content)\n# seed data for the condition command\ndata_weather_attribute = WeatherAttribute(text=\"rains\")\ndata_model.append(data_weather_attribute)\ndata_date_time_tomorrow = DateTime(text=\"tomorrow\")\ndata_model.append(data_date_time_tomorrow)\ndata_model.append(\nWeatherForecastEntity(\nattribute=data_weather_attribute,\ndate_time=data_date_time_tomorrow\n)\n)\n</code></pre> <p>We start by importing the necessary classes. Don't bother yourself too much with it. These are just the classes that will be used to seed the data and the test itself so you can always go back and add them as you write the test.</p> <p>Next we are creating a <code>DataModel</code> object and setting the <code>reset</code> attribute to <code>True</code>.</p> <p>We then seed the data for the first command. We create a <code>Contact</code> object and set the <code>text</code> attribute to the contact name. We then append the object to the data model. We do the same for the reminder content. We then seed the data for the condition command. We create a <code>WeatherAttribute</code> object and set the <code>text</code> attribute to the weather attribute. We then append the object to the data model. We do the same for the <code>DateTime</code> object with the date and time. We then append a <code>WeatherEntity</code> object to the data model. This object will be used to test the generated code.</p> <p>Note</p> <p>The <code>WeatherEntity</code> object is a special case. It is not an entity that should be created like <code>MessageEntity</code> or <code>ReminderEndity</code>. It is something the generated code expects to fetch so we create it for that.</p> <p>We can now write our conditional complex command test.</p> <pre><code>data_messages = data_model.get_data(ReminderEntity)\nassert len(data_messages) == 1\ndata_message = data_messages[0]\nassert test_equal(data_message.data.get(\"person_reminded\"), data_person_reminded)\nassert test_equal(data_message.data.get(\"content\"), data_content)\n</code></pre> <p>With conditional complex commands, we only test the expected generated object. This is because the generated code will not generate any objects when the condition is not met. We don't test the expected generated objects for the condition.</p> <p>We now need to test the scenario where the condition is not met. We will do this by changing the weather attribute to something that is not rainy (any text value other than <code>rains</code> will do).</p> <pre><code>from providers.data_model import DataModel\nfrom entities.generic import Contact, Content, DateTime\nfrom entities.reminder import ReminderEntity\nfrom entities.weather import WeatherAttribute, WeatherForecastEntity\ndata_model = DataModel(reset=True)\n# seed data for the 1st command\ndata_person_reminded = Contact(text=\"me\")\ndata_model.append(data_person_reminded)\ndata_content = Content(text=\"bring an umbrella\")\ndata_model.append(data_content)\n# seed data for the condition command\ndata_weather_attribute = WeatherAttribute(text=\"sunny\") # here we change the weather attribute to sunny instead of rains\ndata_model.append(data_weather_attribute)\ndata_date_time_tomorrow = DateTime(text=\"tomorrow\")\ndata_model.append(data_date_time_tomorrow)\ndata_model.append(\nWeatherForecastEntity(\nattribute=data_weather_attribute,\ndate_time=data_date_time_tomorrow\n)\n)\n</code></pre> <p>Now that the weather attribute is not rainy, we should not get a reminder. We can test this by checking that no <code>ReminderEntity</code> objects were generated.</p> <pre><code>data_messages = data_model.get_data(ReminderEntity)\nassert len(data_messages) == 0\n</code></pre> <p>We test that no <code>ReminderEntity</code> objects were generated. This is because the generated code will not generate any objects when the condition is not met.</p> <p>Congratulations! You have now written the test for a conditional complex command.</p>"},{"location":"tests/#complex-command-with-a-loop","title":"Complex command with a loop","text":"<p>Complex commands with a loop allow you to execute a command multiple times. This is useful when you want to execute a command multiple times with different data. The text description of the commands expresses the multiple executions of the command.</p> <p>Now let's look at a complex command with a loop.</p> <p>Remind me to walk the dog every day this week.</p> <p>Seeding the data for a complex command with a loop is a bit more complex than for a simple command. We need to seed the data for the what we will be looping on. In this case, we will be looping on the <code>DateTime</code> objects for the days of the week.</p> <pre><code>from providers.data_model import DataModel\nfrom entities.generic import DateTime, Contact, Content\nfrom entities.reminder import ReminderEntity\nfrom datetime import datetime, timedelta\ndata_model = DataModel(reset=True)\ndata_person_reminded = Contact(text=\"me\")\ndata_model.append(data_person_reminded)\ndata_content = Content(text=\"walk the dog\")\ndata_model.append(data_content)\n# seed data for the looping predicate\ndata_date_times = []\nfor i in range(7):\ndata_date_time = DateTime(text=\"every day this week\", value=datetime(2022, 12, 26) + timedelta(days=i))\ndata_model.append(data_date_time)\ndata_date_times.append(data_date_time)\n</code></pre> <p>Like always, we start by creating a <code>DataModel</code> object and setting the <code>reset</code> attribute to <code>True</code>.</p> <p>We then seed the data for the <code>Contact</code> object for the person to be reminded. We create a <code>Contact</code> object and set the <code>text</code> attribute to the text description of the contact. We then seed the data for the <code>Content</code> object for the content of the reminder. We create a <code>Content</code> object and set the <code>text</code> attribute to the text description of the content. We then append the objects to the data model.</p> <p>We then seed the data for the <code>DateTime</code> objects for the days of the week. In this case we arbitrarily assume <code>every day this week</code> will be the 7 days of the week (you can freely set a different amount of consecutive days). We create a <code>DateTime</code> object and set the <code>text</code> attribute to the text description of the date and time. We then set the <code>value</code> attribute to the actual date and time. We then append the object to the data model. We do the same for the other days of the week.</p> <p>Note</p> <p>In cases we have multiple objects with the same <code>text</code> attribute, we need to set the <code>value</code> attribute to a different value for each object. This is because the <code>text</code> attribute is used to identify the object. If we have multiple objects with the same <code>text</code> attribute, the generated code will not be able to identify the object. The <code>text</code> attribute of the <code>DateTime</code> objects is the same. This is because the text description of the command is the same for all the days of the week. The <code>value</code> attribute is different for each day of the week. This is because the actual date and time is different for each day of the week.</p> <p>Testing the complex command with a loop is similar to testing a simple command. We test the expected generated objects.</p> <pre><code>data_reminders = data_model.get_data(ReminderEntity)\nassert len(data_reminders) == len(data_date_times)\nfor data_date_time_day in data_date_times:\nassert filter(\nlambda data_reminder: test_equal(data_reminder.data.get(\"person_reminded\"), data_person_reminded)\nand test_equal(data_reminder.data.get(\"content\"), data_content)\nand test_equal(data_reminder.data.get(\"date_time\"), data_date_time_day),\ndata_reminders\n)\n</code></pre> <p>We want to check that a reminder was created for each day, the order does not matter. In the spirit, we get the <code>ReminderEntity</code> objects from the data model. We then test that the number of <code>ReminderEntity</code> objects is equal to the number of days we seeded in the test data. We then create a list of the <code>DateTime</code> objects for the days of the week. We then loop through the list of <code>DateTime</code> objects. For each <code>DateTime</code> object, we test that there is a <code>ReminderEntity</code> object with the same <code>person_reminded</code>, <code>content</code>, and <code>date_time</code> attributes.</p> <p>You are now ready to write the test for a complex command with a loop.</p>"},{"location":"reference/","title":"API Reference","text":""},{"location":"reference/#actions","title":"Actions","text":"<p>The API supports the following actions:</p> <ul> <li>Event</li> <li>Message</li> <li>Navigation</li> <li>Reminder</li> <li>Reponder</li> <li>Weather</li> </ul>"},{"location":"reference/#data-types","title":"Data types","text":"<p>Data types support the resolution of information from the user requests to be used in the API actions.</p> <p>The following datat types are available:</p> <ul> <li>App</li> <li>Contact</li> <li>Content</li> <li>DateTime</li> <li>EventCalendar</li> <li>EventName</li> <li>Location</li> <li>MessageContentType</li> <li>MessageStatus</li> <li>NavRoadCondition</li> <li>NavTravelMethod</li> <li>WeatherAttribute</li> <li>WeatherTemperatureUnit</li> </ul>"},{"location":"reference/actions/event/","title":"Event","text":"<p>Events can be public or private. Public events are for example a concert in the park or a game, where there is a general knowledge about the event and its details. A private event can appear as an entry in the user calendar and include information about the event in a calendar app.</p>"},{"location":"reference/actions/event/#eventfind_events","title":"<code>Event.find_events</code>","text":"<p>This API provides us with events information.</p> <pre><code>Event.find_events(\ndate_time: Optional[DateTime],\nlocation: Optional[Location],\nevent_name: Optional[EventName],\nevent_calendar: Optional[EventCalendar],\napp: Optional[Resurce]\n) : List[EventEntity]\n</code></pre> <p>Arguments</p> Name Type Optional Description <code>date_time</code> <code>DateTime</code> Yes Date and time of the event <code>location</code> <code>Location</code> Yes Event location <code>event_name</code> <code>EventName</code> Yes The event name <code>event_calendar</code> <code>EventCalendar</code> Yes The calendar name where the event should be listed <code>app</code> <code>App</code> Yes The event app application <p>Returns</p> Type Description <code>List[EventEntity]</code> List of <code>EventEntity</code> objects <p>Example</p> <p>When is the Eagles concert with Chris Stapleton coming to Dallas?</p> <pre><code>event_name = EventName.resolve_from_text(\"Eagles concert with Chris Stapleton\")\nlocation = Location.resolve_from_text(\"Dallas\")\nevents = Event.find_events(\nevent_name=event_name,\nlocation=location\n)\nResponder.respond(response=events)\n</code></pre> <p>Example</p> <p>Show me my next meeting on my work calendar.</p> <pre><code>event_name = EventName.resolve_from_text(\"next meeting\")\nevent_calendar = EventCalendar.resolve_from_text(\"my work calendar\")\nevents = Event.find_events(\nevent_category=event_category,\nevent_calendar=event_calendar\n)\nevents = utils.first(events)\nResponder.respond(response=events)\n</code></pre>"},{"location":"reference/actions/message/","title":"Message","text":"<p>Messages can be emails or direct message apps (like Whatsapp). By default, the API will assume emails are requested. In cast another app shuld be used, the API provides the <code>app</code> parameter to serve that.</p>"},{"location":"reference/actions/message/#messagefind_messages","title":"<code>Message.find_messages</code>","text":"<p>This API provides us the messages in our mobile device.</p> <pre><code>Message.find_messages(\ndate_time: Optional[DateTime],\nsender: Optional[Contact],\nrecipient: Optional[Contact],\ncontent: Optional[Content],\nmessage_status: Optional[MessageStatus],\nmessage_content_type: Optional[MessageContentType],\napp: Optional[App]\n) : List[MessageEntity]\n</code></pre> <p>Arguments</p> Name Type Optional Description <code>date_time</code> <code>DateTime</code> Yes Date and time the message was recieved <code>sender</code> <code>Contact</code> Yes Message sender <code>recipient</code> <code>Contact</code> Yes Message recipient <code>content</code> <code>Content</code> Yes Content within the message <code>message_status</code> <code>MessageStatus</code> Yes The message status. For example, \"unread\" or \"new\" <code>message_content_type</code> <code>MessageContentType</code> Yes The message content type <code>app</code> <code>App</code> Yes The message app application <p>Returns</p> Type Description <code>List[MessageEntity]</code> List of <code>MessageEntity</code> objects <p>Example</p> <p>Read the last unread message from aunt Bessy</p> <pre><code>sender = Contact.resolve_from_text(\"aunt Bessy\")\nmessage_status = MessageStatus.resolve_from_text(\"unread\")\nmessages = Message.find_messages(\nsender=sender,\nmessage_status=message_status\n)\nmessage = utils.last(messages)\nResponder.respond(response=message)\n</code></pre>"},{"location":"reference/actions/message/#messagesend_message","title":"<code>Message.send_message</code>","text":"<p>This API provides us the functionality of sending a message.</p> <pre><code>Message.send_message(\nrecipient: Optional[Contact],\ncontent: Optional[Content],\nmessage_content_type: Optional[MessageContentType],\napp: Optional[Resurce]\n) : MessageEntity\n</code></pre> <p>Arguments</p> Name Type Optional Description <code>recipient</code> <code>Contact</code> Yes Message recipient <code>content</code> <code>Content</code> Yes Content within the message <code>message_content_type</code> <code>MessageContentType</code> Yes The message content type <code>app</code> <code>App</code> Yes The message app application <p>Returns</p> Type Description <code>MessageEntity</code> The message object that was sent <p>Example</p> <p>Record a voice message for Daryl</p> <pre><code>contact = Contact.resolve_from_text(\"Daryl\")\nsender = contact\nmessage_content_type = MessageContentType.resolve_from_text(\"voice\")\nmessages = Message.send_message(\nsender=sender,\nmessage_content_type=message_content_type\n)\n</code></pre>"},{"location":"reference/actions/message/#messagereply_message","title":"<code>Message.reply_message</code>","text":"<p>This API provides us the functionality of replying to a message, when the user explicitly states a reply action.</p> <pre><code>Message.reply_message(\nrecipient: Optional[Contact],\ncontent: Optional[Content],\nmessage_content_type: Optional[MessageContentType],\napp: Optional[Resurce]\n) : MessageEntity\n</code></pre> <p>Arguments</p> Name Type Optional Description <code>recipient</code> <code>Contact</code> Yes Message recipient <code>content</code> <code>Content</code> Yes Content within the message <code>message_content_type</code> <code>MessageContentType</code> Yes The message content type <code>app</code> <code>App</code> Yes The message app application <p>Returns</p> Type Description <code>MessageEntity</code> The message object that was sent <p>Example</p> <p>Reply with a voice message to Stephanie on Whatsapp</p> <pre><code>contact = Contact.resolve_from_text(\"Stephanie\")\nsender = contact\nmessage_content_type = MessageContentType.resolve_from_text(\"voice\")\napp = App.resolve_from_text(\"Whatsapp\")\nmessages = Message.reply_message(\nsender=sender,\nmessage_content_type=message_content_type,\napp=app\n)\n</code></pre>"},{"location":"reference/actions/message/#messagedelete_messages","title":"<code>Message.delete_messages</code>","text":"<p>This API provides us the functionality to delete a specific message or a group of messages.</p> <pre><code>Message.delete_messages(\nmessages: MessageEntity|List[MessageEntity]\n) : None\n</code></pre> <p>Arguments</p> Name Type Optional Description <code>messages</code> <code>MessageEntity|List[MessageEntity]</code> No A specific message or a list of messages to delete <p>Returns</p> <p>This function does not return.</p> <p>Example</p> <p>Delete the last 2 messages</p> <pre><code>messages = Message.find_messages()\nmessages = utils.last(messages, 2)\nMessage.delete_messages(messages=messages)\n</code></pre>"},{"location":"reference/actions/message/#messagearchive_messages","title":"<code>Message.archive_messages</code>","text":"<p>This API provides us the functionality to archive a specific message or a group of messages.</p> <pre><code>Message.archive_messages(\nmessages: MessageEntity|List[MessageEntity]\n) : None\n</code></pre> <p>Arguments</p> Name Type Optional Description <code>messages</code> <code>MessageEntity|List[MessageEntity]</code> No A specific message or a list of messages to archive <p>Returns</p> <p>This function does not return.</p> <p>Example</p> <p>Archive the messages that are marked as read from Debby.</p> <pre><code>sender = Contact.resolve_from_entity(\"Debby\")\nmessage_status = MessageStatus.resolve_from_text(\"marked as read\")\nmessages = Message.find_messages(\nsender=sender,\nmessage_status=message_status\n)\nMessage.archive_messages(messages=messages)\n</code></pre>"},{"location":"reference/actions/navigation/","title":"Navigation","text":""},{"location":"reference/actions/navigation/#navigationfind_directions","title":"<code>Navigation.find_directions</code>","text":"<p>This API can support a user request for getting directions from a specific origin to a destination at a specific time.</p> <pre><code>Navigation.find_directions(\norigin: Optional[Location],\ndestination: Optional[Location],\ndeparture_date_time: Optional[DateTime],\navoid_nav_road_condition: Optional[NavRoadCondition],\nnav_travel_method: Optional[NavTravelMethod]\n) : List[NavigationDirectionEntity]\n</code></pre> <p>Arguments</p> Name Type Optional Description <code>origin</code> <code>Location</code> Yes Origin object <code>destination</code> <code>Location</code> Yes Destination object <code>departure_date_time</code> <code>DateTime</code> Yes Required Date/time for departure <code>avoid_nav_road_condition</code> <code>NavRoadCondition</code> Yes Navigation road condition to avoid <code>nav_travel_method</code> <code>NavTravelMethod</code> Yes Navigation travel method. Defaults to car driving, so use it only in case the travel of method is not a car. <p>Returns</p> Type Description <code>List[NavigationDirectionEntity]</code> A list of <code>NavigationRoute</code> objects, which are sorted by default according to the app defined best routes criteria. <p>Example</p> <p>Get directions from Manhattan to Newark that avoid tollways.</p> <pre><code>origin = Location.resolve_from_text(\"Manhattan\")\ndestination = Location.resolve_from_text(\"Newark\")\navoid_nav_road_condition = NavRoadCondition.resolve_from_text(\"tollways\")\nnavigation_directions = Navigation.find_directions(\norigin=origin, \ndestination=destination, \navoid_nav_road_condition=avoid_nav_road_condition\n)\nResponder.respond(response=navigation_directions)\n</code></pre>"},{"location":"reference/actions/navigation/#navigationfind_distance","title":"<code>Navigation.find_distance</code>","text":"<p>This API can support a user request for getting directions from a specific origin to a destination at a specific time.</p> <pre><code>Navigation.find_distance(\norigin: Optional[Location],\ndestination: Optional[Location],\ndeparture_date_time: Optional[DateTime],\navoid_nav_road_condition: Optional[NavRoadCondition],\nnav_travel_method: Optional[NavTravelMethod]\n) : List[NavigationDistanceEntity]\n</code></pre> <p>Arguments</p> Name Type Optional Description <code>origin</code> <code>Location</code> Yes Origin object <code>destination</code> <code>Location</code> Yes Destination object <code>departure_date_time</code> <code>DateTime</code> Yes Required Date/time for departure <code>avoid_nav_road_condition</code> <code>NavRoadCondition</code> Yes NavigationDistance road condition to avoid <code>nav_travel_method</code> <code>NavTravelMethod</code> Yes NavigationDistance method <p>Returns</p> Type Description <code>List[NavigationDistanceEntity]</code> A list of <code>NavigationDistanceEntity</code> objects, which are sorted by default according to the app defined best routes criteria. <p>Example</p> <p>How far is New York from Boston?</p> <pre><code>origin = Location.resolve_from_text(\"New York\")\ndestination = Location.resolve_from_text(\"Boston\")\nnavigation_distance = Navigation.find_distance(\norigin=origin,\ndestination=destination\n)\nResponder.respond(response=navigation_distance)\n</code></pre>"},{"location":"reference/actions/navigation/#navigationfind_duration","title":"<code>Navigation.find_duration</code>","text":"<p>This API can support a user request for estimating the duration for travelling from one place to another.</p> <pre><code>Navigation.find_duration(\norigin: Optional[Location],\ndestination: Optional[Location],\ndeparture_date_time: Optional[DateTime],\navoid_nav_road_condition: Optional[NavRoadCondition],\nnav_travel_method: Optional[NavTravelMethod]\n) : List[NavigationDurationEntity]\n</code></pre> <p>Arguments</p> Name Type Optional Description <code>origin</code> <code>Location</code> Yes Origin object <code>destination</code> <code>Location</code> Yes Destination object <code>departure_date_time</code> <code>DateTime</code> Yes Required Date/time for departure <code>avoid_nav_road_condition</code> <code>NavRoadCondition</code> Yes Navigation road condition to avoid <code>nav_travel_method</code> <code>NavTravelMethod</code> Yes Navigation method <p>Returns</p> Type Description <code>NavigationDurationEntity</code> A list of <code>NavigationDurationEntity</code> objects that provide the estimated travel duration response. <p>Example</p> <p>How long is my drive to Reno, Nevada?</p> <pre><code>destination = Location.resolve_from_text(\"Reno, Nevada\")\nnav_travel_method = DateTime.resolve_from_text(\"drive\")\nnavigation_duration = Navigation.find_duration(\ndestination=destination, \nnav_travel_method=nav_travel_method\n)\nResponder.respond(response=navigation_duration)\n</code></pre>"},{"location":"reference/actions/navigation/#navigationfind_estimated_arrival","title":"<code>Navigation.find_estimated_arrival</code>","text":"<p>This API can support a user request for estimating an arrival time to a place.</p> <pre><code>Navigation.find_estimated_arrival(\norigin: Optional[Location],\ndestination: Optional[Location],\ndeparture_date_time: Optional[DateTime],\narrival_date_Time: Optional[DateTime],\navoid_nav_road_condition: Optional[NavRoadCondition],\nnav_travel_method: Optional[NavTravelMethod]\n) : List[NavigationEstimatedArrivalEntity]\n</code></pre> <p>Arguments</p> Name Type Optional Description <code>origin</code> <code>Location</code> Yes Origin object <code>destination</code> <code>Location</code> Yes Destination object <code>departure_date_time</code> <code>DateTime</code> Yes Date/time of departure <code>arrival_date_time</code> <code>DateTime</code> Yes Required Date/time for arrival <code>avoid_nav_road_condition</code> <code>NavRoadCondition</code> Yes Navigation road condition to avoid <code>nav_travel_method</code> <code>NavTravelMethod</code> Yes Navigation method <p>Returns</p> Type Description <code>List[NavigationEstimatedArrivalEntity]</code> A list of <code>NavigationEstimatedArrivalEntity</code> objects that provides the estimated arrival information, like arrival time, to a destination. This list is returned sorted by default according to the app specific sorting criteria. <p>Example</p> <p>Will traffic make me late for work at 5pm if I leave now</p> <pre><code>destination = Location.resolve_from_text(\"work\")\narrival_date_time = DateTime.resolve_from_text(\"5pm\")\ndeparture_date_time = DateTime.resolve_from_text(\"now\")\nnavigation_estimated_arrival = Navigation.find_estimated_arrival(\ndestination=destination, \ndeparture_date_time=departure_date_time,\narrival_date_time=arrival_date_time\n)\nResponder.respond(response=navigation_estimated_arrival)\n</code></pre>"},{"location":"reference/actions/navigation/#navigationfind_estimated_departure","title":"<code>Navigation.find_estimated_departure</code>","text":"<p>This API can support a user request for estimating departure information from a place.</p> <pre><code>Navigation.find_estimated_departure(\norigin: Optional[Location],\ndestination: Optional[Location],\ndeparture_date_time: Optional[DateTime],\narrival_date_Time: Optional[DateTime],\navoid_nav_road_condition: Optional[NavRoadCondition],\nnav_travel_method: Optional[NavTravelMethod]\n) : List[NavigationEstimatedDepartureEntity]\n</code></pre> <p>Arguments</p> Name Type Optional Description <code>origin</code> <code>Location</code> Yes Origin object <code>destination</code> <code>Location</code> Yes Destination object <code>departure_date_time</code> <code>DateTime</code> Yes Required Date/time for departure <code>arrival_date_time</code> <code>DateTime</code> Yes Date/time of arrival <code>avoid_nav_road_condition</code> <code>NavRoadCondition</code> Yes NavigationEstimatedDeparture road condition to avoid <code>nav_travel_method</code> <code>NavTravelMethod</code> Yes NavigationEstimatedDeparture method <p>Returns</p> Type Description <code>List[NavigationEstimatedDepartureEntity]</code> A list of <code>NavigationEstimatedDepartureEntity</code> objects that provides the estimated departure information, like time to depart, from an origin. This list is returned sorted by default according to the app specific sorting criteria. <p>Example</p> <p>I have to pick someone up at the airport during rush hour, what time should I leave home in order to meet a 6PM flight</p> <pre><code>destination = Location.resolve_from_text(\"the airport\")\norigin = Location.resolve_from_text(\"home\")\narrival_date_time = DateTime.resolve_from_text(\"a 6PM flight\")\nnavigation_estimated_departure = Navigation.find_estimated_departure(\ndestination=destination, \norigin=origin,\narrival_date_time=arrival_date_time\n)\nResponder.respond(response=navigation_estimated_departure)\n</code></pre>"},{"location":"reference/actions/navigation/#navigationfind_traffic_info","title":"<code>Navigation.find_traffic_info</code>","text":"<p>This API can support a user request for information on traffic conditions.</p> <pre><code>Navigation.find_traffic_info(\nlocation: Optional[Location],\norigin: Optional[Location],\ndestination: Optional[Location],\ndate_time: Optional[DateTime],\ndeparture_date_time: Optional[DateTime],\navoid_nav_road_condition: Optional[NavRoadCondition],\nnav_travel_method: Optional[NavTravelMethod]\n) : List[NavigationTrafficInfoEntity]\n</code></pre> <p>Arguments</p> Name Type Optional Description <code>origin</code> <code>Location</code> Yes Origin object <code>location</code> <code>Location</code> Yes Requested location for traffic infomration <code>destination</code> <code>Location</code> Yes Destination object <code>date_time</code> <code>DateTime</code> Yes Requested date and time for traffic information <code>departure_date_time</code> <code>DateTime</code> Yes Required Date/time for departure <code>avoid_nav_road_condition</code> <code>NavRoadCondition</code> Yes NavigationTrafficInfo road condition to avoid <code>nav_travel_method</code> <code>NavTravelMethod</code> Yes NavigationTrafficInfo method <p>Returns</p> Type Description <code>List[NavigationTrafficInfoEntity]</code> A list of <code>NavigationTrafficInfoEntity</code> objects that provides the estimated traffic information. <p>Example</p> <p>Is traffic heavy right now in Minneapolis</p> <pre><code>date_time = DateTime.resolve_from_text(\"right now\")\nlocation = Location.resolve_from_text(\"Minneapolis\")\ntraffic_infos = Navigation.find_traffic_info(\ndate_time=date_time,\nlocation=location\n)\nResponder.respond(response=traffic_infos)\n</code></pre>"},{"location":"reference/actions/reminder/","title":"Reminder","text":""},{"location":"reference/actions/reminder/#reminderfind_reminders","title":"<code>Reminder.find_reminders</code>","text":"<p>This API provides us the reminders in our mobile device.</p> <pre><code>Reminder.find_reminders(\ndate_time: Optional[DateTime],\nperson_reminded: Optional[Contact],\ncontent: Optional[Content],\napp: Optional[Resurce]\n) : List[ReminderEntity]\n</code></pre> <p>Arguments</p> Name Type Optional Description <code>date_time</code> <code>DateTime</code> Yes Date and time the reminder was recieved <code>person_reminded</code> <code>Contact</code> Yes Reminder contact reminded <code>content</code> <code>Content</code> Yes Content within the reminder <code>app</code> <code>App</code> Yes The reminder app application <p>Returns</p> Type Description <code>List[ReminderEntity]</code> List of <code>ReminderEntity</code> objects <p>Example</p> <p>What reminders do I have on next friday?</p> <pre><code>contact = Contact.resolve_from_text(\"I\")\nperson_reminded = contact\ndate_time = DateTime.resolve_from_text(\"on next friday\")\nreminders = Reminder.find_reminders(\nsender=sender,\ndate_time=date_time\n)\nresponse = reminders\nResponder.respond(response=response)\n</code></pre>"},{"location":"reference/actions/reminder/#remindercreate_reminder","title":"<code>Reminder.create_reminder</code>","text":"<p>This API provides us the functionality of creating a reminder.</p> <pre><code>Reminder.create_reminder(\ndate_time: Optional[DateTime],\nperson_reminded: Optional[Contact],\ncontent: Optional[Content],\napp: Optional[Resurce]\n) : ReminderEntity\n</code></pre> <p>Arguments</p> Name Type Optional Description <code>date_time</code> <code>DateTime</code> Yes Date and time the reminder was recieved <code>person_reminded</code> <code>Contact</code> Yes Reminder contact reminded <code>content</code> <code>Content</code> Yes Content within the reminder <code>app</code> <code>App</code> Yes The reminder app application <p>Returns</p> Type Description <code>ReminderEntity</code> The reminder object that was created <p>Example</p> <p>Remind dance troupe to bring extra socks to practice.</p> <pre><code>contact = Contact.resolve_from_text(\"dance troupe\")\nperson_reminded = contact\ncontent = Content.resolve_from_text(\"bring extra socks to practice.\")\nreminders = Reminder.create_reminder(\nperson_reminded=person_reminded,\ncontent=content\n)\n</code></pre>"},{"location":"reference/actions/reminder/#reminderupdate_reminder","title":"<code>Reminder.update_reminder</code>","text":"<p>This API provides us the functionality of updating a reminder.</p> <pre><code>Reminder.update_reminder(\ndate_time: Optional[DateTime],\nnew_date_time: Optional[DateTime],\nperson_reminded: Optional[Contact],\nnew_person_reminded: Optional[Contact],\ncontent: Optional[Content],\nnew_content: Optional[Content],\napp: Optional[Resurce],\nnew_app: Optional[Resurce]\n) : ReminderEntity\n</code></pre> <p>Arguments</p> Name Type Optional Description <code>date_time</code> <code>DateTime</code> Yes Date and time the reminder was recieved <code>new_date_time</code> <code>DateTime</code> Yes New date and time the reminder was recieved <code>person_reminded</code> <code>Contact</code> Yes Reminder contact reminded <code>new_person_reminded</code> <code>Contact</code> Yes Reminder to a new contact reminded <code>content</code> <code>Content</code> Yes Content within the reminder <code>new_content</code> <code>Content</code> Yes New content within the reminder <code>app</code> <code>App</code> Yes The reminder app application <code>new_app</code> <code>App</code> Yes A new reminder app application <p>Returns</p> Type Description <code>ReminderEntity</code> The reminder object that was updated <p>Example</p> <p>Change my reminder for the doctor's appointment at 11am to 10am</p> <pre><code>contact = Contact.resolve_from_text(\"Stephanie\")\ncontactt_reminded = contact\ncontent = Content.resolve_from_text(\"the doctor's appointment\")\ndate_time = DateTime.resolve_from_text(\"at 11am\")\nnew_date_time = DateTime.resolve_from_text(\"10am\")\nreminders = Reminder.reply_reminder(\ncontactt_reminded=contactt_reminded,\ncontent=content,\ndate_time=date_time,\nnew_date_time=new_date_time\n)\n</code></pre>"},{"location":"reference/actions/reminder/#reminderdelete_reminders","title":"<code>Reminder.delete_reminders</code>","text":"<p>This API provides us the functionality to delete specific reminder or a group of reminders.</p> <pre><code>Reminder.reply_reminders(\nreminder: ReminderEntity|List[ReminderEntity]\n) : None\n</code></pre> <p>Arguments</p> Name Type Optional Description <code>reminders</code> <code>ReminderEntity|List[ReminderEntity]</code> No A specific reminder to delete or an iterable that upon iteration - deletes every reminder <p>Returns</p> <p>This function does not return.</p> <p>Example</p> <p>Cancel the reminder on the 31st that the library summer reading program shop closes.</p> <pre><code>content = Content.resolve_from_text(\"the library summer reading program shop closes\")\ndate_time = DateTime.resolve_from_text(\"on the 31st\")\nreminders = Reminder.find_reminders(\ncontent=content,\ndate_time=date_time\n)\nReminder.delete_reminders(reminders=reminders)\n</code></pre>"},{"location":"reference/actions/responder/","title":"Responder","text":""},{"location":"reference/actions/responder/#responderrespond","title":"<code>Responder.respond</code>","text":"<p>Whenever users ask quetions that requires a specific response, or request something to be displayed or read to them - this is where the <code>Responder</code> comes handy. It sole role is to deliver the information to the user on screen or on audio.</p> <pre><code>Responder.find_events(\nresponse: Entity\n) : None\n</code></pre> <p>Arguments</p> Name Type Optional Description <code>response</code> <code>Entity|List[Entity]</code> No The <code>Responder</code> is able to transform any given <code>Entity</code> or a list of <code>Entity</code> to a user expected response form to the user. <p>Note</p> <p><code>Entity</code> is the base class of all entities returned by any of the other actions listed in this reference.</p> <p>Returns</p> <p>This function does not return.</p> <p>Example</p> <p>When is the Eagles concert with Chris Stapleton coming to Dallas?</p> <pre><code>event_name = ResponderName.resolve_from_text(\"Eagles concert with Chris Stapleton\")\nevent_category = ResponderCategory.resolve_from_text(\"concert\")\nlocation = Location.resolve_from_text(\"Dallas\")\nevents = Event.find(\nevent_name=event_name,\nevent_category=event_category,\nlocation=location\n)\nResponder.respond(response=events)\n</code></pre> <p>Example</p> <p>Show me my next meeting on my work calendar.</p> <pre><code>event_category = ResponderCategory.resolve_from_text(\"meeting\")\nevent_calendar = ResponderCalendar.resolve_from_text(\"my work calendar\")\nevents = Event.find(\nevent_category=event_category,\nevent_calendar=event_calendar\n)\nevents = utils.first(events)\nResponder.respond(response=events)\n</code></pre>"},{"location":"reference/actions/shopping/","title":"Shopping","text":"<p>Shopping</p>"},{"location":"reference/actions/shopping/#shoppingfind_stores","title":"<code>Shopping.find_stores</code>","text":"<p>This API allows us to find stores according to specific criteria, like the products sold in these stores, or when these stores are open.</p> <pre><code>Shopping.find_stores(\ndate_time: Optional[DateTime],\nlocation: Optional[Location],\nproduct: Optional[Product],\nplace_attribute: Optional[PlaceAttribute],\n) : List[StoreEntity]\n</code></pre> <p>Arguments</p> Name Type Optional Description <code>date_time</code> <code>DateTime</code> Yes Date and time of the event <code>location</code> <code>Location</code> Yes Location of the store <code>product</code> <code>CommerceCategory</code> Yes The product sold bt the store <code>place_attr</code> <code>PlaceAttribtue</code> Yes Attributes of the store. For example, is it close or open, ratings, peak hours, etc. <p>Returns</p> Type Description <code>List[StoreEntity]</code> List of <code>StoreEntity</code> objects <p>Example</p> <p>Find all open stores near my office that sell discounted Skippy peanut butter.</p> <pre><code>place_attribute = PlaceAttribute.resolve_from_text(\"open\")\nlocation = Location.resolve_from_text(\"near my office\")\nproduct = Product.resolve_from_text(\"discounted Skippy peanut butter\")\nstores = Shopping.find_stores(\nplace_attribute=place_attribute,\nlocation=location,\nproduct=product\n)\nResponder.respond(response=stores)\n</code></pre>"},{"location":"reference/actions/weather/","title":"Weather","text":""},{"location":"reference/actions/weather/#weatherfind_weather_forecasts","title":"<code>Weather.find_weather_forecasts</code>","text":"<p>This API provides us the weather forecasts.</p> <pre><code>Weather.find_weather_forecasts(\ndate_time: Optional[DateTime] | List[DateTime],\nlocation: Optional[Location],\nweather_attribute: Optional[WeatherAttribute],\nweather_temperature_unit: Optional[WeatherTemperatureUnit]\n) : List[WeatherEntity]\n</code></pre> <p>Arguments</p> Name Type Optional Description <code>date_time</code> <code>DateTime | List[DateTime]</code> Yes Date and time for the weather. An input of <code>location</code> <code>Location</code> Yes Location for the weather <code>weather_attribute</code> <code>WeatherAttribute</code> Yes Weather attribute to look for in the weather forecasts <code>weather_temperature_unit</code> <code>WeatherTemperatureUnit</code> Yes Weather temperature unit to be used in the weather query <p>Returns</p> Type Description <code>List[WeatherEntity]</code> List of <code>WeatherEntity</code> objects. Each <code>WeatherEntity</code> provides the requested weather forecast for a time frame (e.g. for each day). <p>Example</p> <p>This query should return a report by the virtual assistant upon rain tonight.</p> <p>Note</p> <p>Please note that some argument are unspecified and in that case the implementation of this method assume their value. For example, <code>Location</code> is not specified and therefore the system assumes the location for the weather forecasts.</p> <p>Is it raining tonight?</p> <pre><code>weather_attribute = WeatherAttribute.resolve_from_text(\"raining\")\ndate_time = DateTime.resolve_from_text(\"tonight\")\nweather_forecasts = Weather.find_weather_forecasts(\nweather_attribute=weather_attribute,\ndate_time=date_time\n)\nresponse = weather_forecasts\nResponder.respond(response=response)\n</code></pre>"},{"location":"reference/actions/navigation/navigation_direction/","title":"NavigationDirection","text":""},{"location":"reference/actions/navigation/navigation_direction/#navigationdirectionfind","title":"<code>NavigationDirection.find</code>","text":"<p>This API can support a user request for getting directions from a specific origin to a destination at a specific time.</p> <pre><code>NavigationDirection.find(\norigin: Optional[Location],\ndestination: Optional[Location],\ndeparture_date_time: Optional[DateTime],\navoid_nav_road_condition: Optional[NavRoadCondition],\nnav_travel_method: Optional[NavTravelMethod]\n) : List[NavigationDirectionEntity]\n</code></pre> <p>Arguments</p> Name Type Optional Description <code>origin</code> <code>Location</code> Yes Origin object <code>destination</code> <code>Location</code> Yes Destination object <code>departure_date_time</code> <code>DateTime</code> Yes Required Date/time for departure <code>avoid_nav_road_condition</code> <code>NavRoadCondition</code> Yes Navigation road condition to avoid <code>nav_travel_method</code> <code>NavTravelMethod</code> Yes Navigation method <p>Returns</p> Type Description <code>List[NavigationDirectionEntity]</code> A list of <code>NavigationRoute</code> objects, which are sorted by default according to the app defined best routes criteria. <p>Example</p> <p>Get directions from Manhattan to Newark that avoid tollways.</p> <pre><code>origin = Location.resolve_from_text(\"Manhattan\")\ndestination = Location.resolve_from_text(\"Newark\")\navoid_nav_road_condition = NavRoadCondition.resolve_from_text(\"tollways\")\nnavigation_directions = NavigationDirection.find(\norigin=origin, \ndestination=destination, \navoid_nav_road_condition=avoid_nav_road_condition\n)\nResponder.respond(response=navigation_directions)\n</code></pre>"},{"location":"reference/actions/navigation/navigation_distance/","title":"NavigationDistance","text":""},{"location":"reference/actions/navigation/navigation_distance/#navigationdistancefind","title":"<code>NavigationDistance.find</code>","text":"<p>This API can support a user request for getting directions from a specific origin to a destination at a specific time.</p> <pre><code>Weather.find(\norigin: Optional[Location],\ndestination: Optional[Location],\ndeparture_date_time: Optional[DateTime],\navoid_nav_road_condition: Optional[NavRoadCondition],\nnav_travel_method: Optional[NavTravelMethod]\n) : List[NavigationDistanceEntity]\n</code></pre> <p>Arguments</p> Name Type Optional Description <code>origin</code> <code>Location</code> Yes Origin object <code>destination</code> <code>Location</code> Yes Destination object <code>departure_date_time</code> <code>DateTime</code> Yes Required Date/time for departure <code>avoid_nav_road_condition</code> <code>NavRoadCondition</code> Yes NavigationDistance road condition to avoid <code>nav_travel_method</code> <code>NavTravelMethod</code> Yes NavigationDistance method <p>Returns</p> Type Description <code>List[NavigationDistanceEntity]</code> A list of <code>NavigationDistanceEntity</code> objects, which are sorted by default according to the app defined best routes criteria. <p>Example</p> <p>How far is New York from Boston?</p> <pre><code>origin = Location.resolve_from_text(\"New York\")\ndestination = Location.resolve_from_text(\"Boston\")\nnavigation_distance = NavigationDistance.find(\norigin=origin,\ndestination=destination\n)\nResponder.respond(response=navigation_distance)\n</code></pre>"},{"location":"reference/actions/navigation/navigation_duration/","title":"NavigationDuration","text":""},{"location":"reference/actions/navigation/navigation_duration/#navigationdurationfind","title":"<code>NavigationDuration.find</code>","text":"<p>This API can support a user request for estimating the duration for travelling from one place to another.</p> <pre><code>NavigationDuration.find(\norigin: Optional[Location],\ndestination: Optional[Location],\ndeparture_date_time: Optional[DateTime],\navoid_nav_road_condition: Optional[NavRoadCondition],\nnav_travel_method: Optional[NavTravelMethod]\n) : List[NavigationDurationEntity]\n</code></pre> <p>Arguments</p> Name Type Optional Description <code>origin</code> <code>Location</code> Yes Origin object <code>destination</code> <code>Location</code> Yes Destination object <code>departure_date_time</code> <code>DateTime</code> Yes Required Date/time for departure <code>avoid_nav_road_condition</code> <code>NavRoadCondition</code> Yes Navigation road condition to avoid <code>nav_travel_method</code> <code>NavTravelMethod</code> Yes Navigation method <p>Returns</p> Type Description <code>NavigationDurationEntity</code> A list of <code>NavigationDurationEntity</code> objects that provide the estimated travel duration response. <p>Example</p> <p>How long is my drive to Reno, Nevada?</p> <pre><code>destination = Location.resolve_from_text(\"Reno, Nevada\")\nnav_travel_method = DateTime.resolve_from_text(\"drive\")\nnavigation_duration = NavigationDuration.find(\ndestination=destination, \nnav_travel_method=nav_travel_method\n)\nResponder.respond(response=navigation_duration)\n</code></pre>"},{"location":"reference/actions/navigation/navigation_estimated_arrival/","title":"NavigationEstimatedArrival","text":""},{"location":"reference/actions/navigation/navigation_estimated_arrival/#navigationestimatedarrivalfind","title":"<code>NavigationEstimatedArrival.find</code>","text":"<p>This API can support a user request for estimating an arrival time to a place.</p> <pre><code>NavigationEstimatedArrival.find(\norigin: Optional[Location],\ndestination: Optional[Location],\ndeparture_date_time: Optional[DateTime],\narrival_date_Time: Optional[DateTime],\navoid_nav_road_condition: Optional[NavRoadCondition],\nnav_travel_method: Optional[NavTravelMethod]\n) : List[NavigationEstimatedArrivalEntity]\n</code></pre> <p>Arguments</p> Name Type Optional Description <code>origin</code> <code>Location</code> Yes Origin object <code>destination</code> <code>Location</code> Yes Destination object <code>departure_date_time</code> <code>DateTime</code> Yes Date/time of departure <code>arrival_date_time</code> <code>DateTime</code> Yes Required Date/time for arrival <code>avoid_nav_road_condition</code> <code>NavRoadCondition</code> Yes Navigation road condition to avoid <code>nav_travel_method</code> <code>NavTravelMethod</code> Yes Navigation method <p>Returns</p> Type Description <code>List[NavigationEstimatedArrivalEntity]</code> A list of <code>NavigationEstimatedArrivalEntity</code> objects that provides the estimated arrival information, like arrival time, to a destination. This list is returned sorted by default according to the app specific sorting criteria. <p>Example</p> <p>Will traffic make me late for work at 5pm if I leave now</p> <pre><code>destination = Location.resolve_from_text(\"work\")\narrival_date_time = DateTime.resolve_from_text(\"5pm\")\ndeparture_date_time = DateTime.resolve_from_text(\"now\")\nnavigation_estimated_arrival = NavigationEstimatedArrival.find(\ndestination=destination, \ndeparture_date_time=departure_date_time,\narrival_date_time=arrival_date_time\n)\nResponder.respond(response=navigation_estimated_arrival)\n</code></pre>"},{"location":"reference/actions/navigation/navigation_estimated_departure/","title":"NavigationEstimatedDeparture","text":""},{"location":"reference/actions/navigation/navigation_estimated_departure/#navigationestimateddeparturefind","title":"<code>NavigationEstimatedDeparture.find</code>","text":"<p>This API can support a user request for estimating departure information from a place.</p> <pre><code>NavigationEstimatedDeparture.find(\norigin: Optional[Location],\ndestination: Optional[Location],\ndeparture_date_time: Optional[DateTime],\narrival_date_Time: Optional[DateTime],\navoid_nav_road_condition: Optional[NavRoadCondition],\nnav_travel_method: Optional[NavTravelMethod]\n) : List[NavigationEstimatedDepartureEntity]\n</code></pre> <p>Arguments</p> Name Type Optional Description <code>origin</code> <code>Location</code> Yes Origin object <code>destination</code> <code>Location</code> Yes Destination object <code>departure_date_time</code> <code>DateTime</code> Yes Required Date/time for departure <code>arrival_date_time</code> <code>DateTime</code> Yes Date/time of arrival <code>avoid_nav_road_condition</code> <code>NavRoadCondition</code> Yes NavigationEstimatedDeparture road condition to avoid <code>nav_travel_method</code> <code>NavTravelMethod</code> Yes NavigationEstimatedDeparture method <p>Returns</p> Type Description <code>List[NavigationEstimatedDepartureEntity]</code> A list of <code>NavigationEstimatedDepartureEntity</code> objects that provides the estimated departure information, like time to depart, from an origin. This list is returned sorted by default according to the app specific sorting criteria. <p>Example</p> <p>I have to pick someone up at the airport during rush hour, what time should I leave home in order to meet a 6PM flight</p> <pre><code>destination = Location.resolve_from_text(\"the airport\")\norigin = Location.resolve_from_text(\"home\")\narrival_date_time = DateTime.resolve_from_text(\"a 6PM flight\")\nnavigation_estimated_departure = NavigationEstimatedDeparture.find(\ndestination=destination, \norigin=origin,\narrival_date_time=arrival_date_time\n)\nResponder.respond(response=navigation_estimated_departure)\n</code></pre>"},{"location":"reference/actions/navigation/navigation_traffic_info/","title":"NavigationTrafficInfo","text":""},{"location":"reference/actions/navigation/navigation_traffic_info/#navigationtrafficinfofind","title":"<code>NavigationTrafficInfo.find</code>","text":"<p>This API can support a user request for information on traffic conditions.</p> <pre><code>NavigationTrafficInfo.find(\nlocation: Optional[Location],\norigin: Optional[Location],\ndestination: Optional[Location],\ndate_time: Optional[DateTime],\ndeparture_date_time: Optional[DateTime],\navoid_nav_road_condition: Optional[NavRoadCondition],\nnav_travel_method: Optional[NavTravelMethod]\n) : List[NavigationTrafficInfoEntity]\n</code></pre> <p>Arguments</p> Name Type Optional Description <code>origin</code> <code>Location</code> Yes Origin object <code>location</code> <code>Location</code> Yes Requested location for traffic infomration <code>destination</code> <code>Location</code> Yes Destination object <code>date_time</code> <code>DateTime</code> Yes Requested date and time for traffic information <code>departure_date_time</code> <code>DateTime</code> Yes Required Date/time for departure <code>avoid_nav_road_condition</code> <code>NavRoadCondition</code> Yes NavigationTrafficInfo road condition to avoid <code>nav_travel_method</code> <code>NavTravelMethod</code> Yes NavigationTrafficInfo method <p>Returns</p> Type Description <code>List[NavigationTrafficInfoEntity]</code> A list of <code>NavigationTrafficInfoEntity</code> objects that provides the estimated traffic information. <p>Example</p> <p>Is traffic heavy right now in Minneapolis</p> <pre><code>date_time = DateTime.resolve_from_text(\"right now\")\nlocation = Location.resolve_from_text(\"Minneapolis\")\ntraffic_infos = NavigationTrafficInfo.find(\ndate_time=date_time,\nlocation=location\n)\nResponder.respond(response=traffic_infos)\n</code></pre>"},{"location":"reference/types/app/","title":"App","text":""},{"location":"reference/types/app/#appresolve_from_text","title":"<code>App.resolve_from_text</code>","text":"<p>This API allows us to resolve an app or a website that will use to tp perform an action. For example, an app to send a message or create a reminder.</p> <pre><code>App.resolve_from_text(\ntext: str\n) : App\n</code></pre> <p>Arguments</p> Name Type Optional Description <code>text</code> <code>str</code> No Textual <code>App</code> description <p>Returns</p> Type Description <code>App</code> <code>App</code> object <p>Example</p> <p>A <code>App</code> can be a specific app like Gmail</p> <p>Reply back to Sue on Facebook saying I did not get the invite</p> <pre><code>app = App.resolve_from_text(\"Facebook\")\n</code></pre>"},{"location":"reference/types/contact/","title":"Contact","text":""},{"location":"reference/types/contact/#contactresolve_from_text","title":"<code>Contact.resolve_from_text</code>","text":"<p>This API allows us to resolve a <code>Contact</code> or a list of <code>Contact</code> objects from a given user input. For example, a recipient of a message or a contact to create a reminder for.</p> <pre><code>Contact.resolve_from_text(\ntext: str\n) : Contact\n</code></pre> <p>Arguments</p> Name Type Optional Description <code>text</code> <code>str</code> No Textual Contact description <p>Returns</p> Type Description <code>Contact | List[Contact]</code> <code>Contact</code> object or a list of <code>Contact</code> objects based on the <code>text</code> parameter to this function. <p>Example</p> <p>Remind me tomorrow to postpone my dentist appointment</p> <pre><code>contact = Contact.resolve_from_text(\"me\")\n</code></pre>"},{"location":"reference/types/contact/#contactresolve_many_from_text","title":"<code>Contact.resolve_many_from_text</code>","text":"<p>This API allows us to resolve a list of <code>Contact</code> objects from a given user input. For example, a group of recipients of a message or a contacts to create a reminder for.</p> <pre><code>Contact.resolv_manye_from_text(\ntext: str\n) : List[Contact]\n</code></pre> <p>Arguments</p> Name Type Optional Description <code>text</code> <code>str</code> No Textual Contact description <p>Returns</p> Type Description <code>List[Contact]</code> A list of <code>Contact</code> objects based on the <code>text</code> parameter to this function. <p>Example</p> <p>Remind all my book club tomorrow that the meeting was cancelled</p> <pre><code>contacts = Contact.resolve_many_from_text(\"all my book club\")\n</code></pre>"},{"location":"reference/types/content/","title":"Content","text":""},{"location":"reference/types/content/#contentresolve_from_text","title":"<code>Content.resolve_from_text</code>","text":"<p>This API allows us to resolve the textual content from a given user input, for example, for a reminder or a text message.</p> <pre><code>Content.resolve_from_text(\ntext: str\n) : Content\n</code></pre> <p>Arguments</p> Name Type Optional Description <code>text</code> <code>str</code> No Textual content <p>Returns</p> Type Description <code>Content</code> A <code>Content</code> object based on the <code>text</code> parameter to this function. <p>Example</p> <p>A <code>Content</code> can be a day, a specific time, or any publicly known place (for example, Times Square).</p> <p>Remind me tomorrow to postpone my dentist appointment</p> <pre><code>content = Content.resolve_from_text(\"postpone my dentist appointment\")\n</code></pre> <p>Tip</p> <p>When resolving Content from a text we will usually ignore reference words like \"to\", which are not part of the body of the content (like the message or the reminder).</p>"},{"location":"reference/types/content/#contentresolve_from_entity","title":"<code>Content.resolve_from_entity</code>","text":"<p>This API allows us to resolve a Content from a given entity or list of entities, usually the result of a previous <code>resolve_from_text()</code> operation.</p> <pre><code>Content.resolve_from_entity(\nentity: Entity | List[Entity]\n) : DateTime | List[DateTime]\n</code></pre> <p>Arguments</p> Name Type Optional Description <code>entity</code> <code>Entity | List[Entity]</code> No An <code>Entity</code> object to be transformed to a <code>Content</code> <p>Returns</p> Type Description <code>Content | List[Content]</code> A <code>Content</code> object or a list of <code>Content</code> objects based on the <code>text</code> parameter to this function. <p>Example</p> <p>A <code>Content</code> can be be inferred from different objects. For example, messaging navigation directions where the directions should be transformed to the message content.</p> <p>Send Joshua my arrival time to his house if I leave now</p> <pre><code>location = Location.resolve_from_text(\"his house\")\ndestination = location\ndate_time = DateTime.resolve_from_text(\"now\")\ndeparture_date_time = date_time\nestimated_arrival_time = Navigation.get_estimated_arrival_timie(\ndestination=destination,\ndeparture_date_time=departure_date_time\n)\ncontent = Content.resolve_from_entity(estimated_arrival_time)\n...\n</code></pre>"},{"location":"reference/types/date_time/","title":"DateTime","text":""},{"location":"reference/types/date_time/#datetimeresolve_from_text","title":"<code>DateTime.resolve_from_text</code>","text":"<p>This API allows us to resolve a date or time decription from a given text.</p> <pre><code>DateTime.resolve_from_text(\ntext: str\n) : DateTime\n</code></pre> <p>Arguments</p> Name Type Optional Description <code>text</code> <code>str</code> No Textual decription of a time description <p>Returns</p> Type Description <code>DateTime</code> <code>DateTime</code> object based on the <code>text</code> parameter to this function. <p>Example</p> <p>A <code>DateTime</code> can be a day, a specific time, or any publicly known place (for example, Times Square).</p> <p>If I leave now will I get to 37 Spring St by 12:30 pm?</p> <pre><code>date_time = DateTime.resolve_from_text(\"now\")\n</code></pre>"},{"location":"reference/types/date_time/#datetimeresolve_many_from_text","title":"<code>DateTime.resolve_many_from_text</code>","text":"<p>This API allows us to resolve multiple dates or times from a given text.</p> <pre><code>DateTime.resolve_many_from_text(\ntext: str\n) : List[DateTime]\n</code></pre> <p>Arguments</p> Name Type Optional Description <code>text</code> <code>str</code> No Textual decription of a time description <p>Returns</p> Type Description <code>List[DateTime]</code> A list of <code>DateTime</code> objects based on the <code>text</code> parameter to this function. <p>Example</p> <p>A <code>DateTime</code> can be a logical name for multiple days (for example, the weeekend), or a domain knowledge (public o personal) for a group of times (e.g., the weeks we will be on vacation).</p> <p>What will be the weather during the weekend?</p> <pre><code>date_times = DateTime.resolve_many_from_text(\"the weekend\")\n</code></pre>"},{"location":"reference/types/date_time/#datetimeresolve_from_entity","title":"<code>DateTime.resolve_from_entity</code>","text":"<p>This API allows us to resolve a DateTime from a given entity or list of entities, usually the result of a previous <code>resolve_from_text()</code> operation.</p> <pre><code>DateTime.resolve_from_entity(\nentity: Entity | List[Entity]\n) : DateTime | List[DateTime]\n</code></pre> <p>Arguments</p> Name Type Optional Description <code>entity</code> <code>Entity | List[Entity]</code> No An <code>Entity</code> object to be transformed to a <code>DateTime</code> <p>Returns</p> Type Description <code>DateTime | List[DateTime]</code> A DateTime object or a list of <code>DateTime</code> objects based on the <code>text</code> parameter to this function. <p>Example</p> <p>A <code>DateTime</code> can be be inferred from different objects. For example, an event time or the estimated time of arrival to a place.</p> <p>Will there be traffic downtown during the Rockets game?</p> <pre><code>event_name = EventName.resolve_from_text(\"the Rockets game\")\nevent = Event.find(event_name=event_name)\ndate_time = DateTime.resolve_from_entity(event)\n...\n</code></pre>"},{"location":"reference/types/event_calendar/","title":"EventCalendar","text":""},{"location":"reference/types/event_calendar/#eventcalendarresolve_from_text","title":"<code>EventCalendar.resolve_from_text</code>","text":"<p>This API allows us to resolve a calendar name listing an event from a given user input.</p> <pre><code>EventCalendar.resolve_from_text(\ntext: str\n) : EventCalendar\n</code></pre> <p>Arguments</p> Name Type Optional Description <code>text</code> <code>str</code> No Textual EventCalendar description <p>Returns</p> Type Description <code>EventCalendar</code> <code>EventCalendar</code> object based on the <code>text</code> parameter to this function. <p>Example</p> <p>A <code>EventCalendar</code> is the name of the calendar journey to search or create meeting in.</p> <p>Do I have a townhall meeting this Friday on my work calendar?</p> <pre><code>event_calendar = EventCalendar.resolve_from_text(\"my work calendar\")\n</code></pre>"},{"location":"reference/types/event_calendar/#eventcalendarresolve_many_from_text","title":"<code>EventCalendar.resolve_many_from_text</code>","text":"<p>In some cases it will be required to resolve a group of calendar names.</p> <pre><code>EventCalendar.resolve_many_from_text(\ntext: str\n) : List[EventCalendar]\n</code></pre> <p>Arguments</p> Name Type Optional Description <code>text</code> <code>str</code> No Textual EventCalendar description <p>Returns</p> Type Description <code>List[EventCalendar]</code> A list of <code>EventCalendar</code> objects based on the <code>text</code> parameter to this function. <p>Example</p> <p>A <code>EventCalendar</code> is the name of the calendar journey to search or create meeting in.</p> <p>Search my kids' calendars for any activity tomorrow at 6 pm.</p> <pre><code>event_calendars = EventCalendar.resolve_many_from_text(\"my kids' calendars\")\n</code></pre>"},{"location":"reference/types/event_category/","title":"EventCategory","text":""},{"location":"reference/types/event_category/#eventcategoryresolve_from_text","title":"<code>EventCategory.resolve_from_text</code>","text":"<p>This API allows us to resolve an event category from a given user input.</p> <pre><code>EventCategory.resolve_from_text(\ntext: str\n) : EventCategory\n</code></pre> <p>Arguments</p> Name Type Optional Description <code>text</code> <code>str</code> No Textual description of the event category <p>Returns</p> Type Description <code>EventCategory</code> <code>EventCategory</code> object based on the <code>text</code> parameter to this function. <p>Example</p> <p>Show me Christmas parties for kids in atlanta</p> <pre><code>event_category = EventCategory.resolve_from_text(\"parties\")\n</code></pre>"},{"location":"reference/types/event_name/","title":"EventName","text":""},{"location":"reference/types/event_name/#eventnameresolve_from_text","title":"<code>EventName.resolve_from_text</code>","text":"<p>This API allows us to resolve a calendar event name from a given user input.</p> <pre><code>EventName.resolve_from_text(\ntext: str\n) : EventName\n</code></pre> <p>Arguments</p> Name Type Optional Description <code>text</code> <code>str</code> No Textual description of the event name <p>Returns</p> Type Description <code>EventName</code> <code>EventName</code> object based on the <code>text</code> parameter to this function. <p>Example</p> <p>A <code>EventName</code> is the reference to name or title of calendar meetings.</p> <p>Do I have a townhall meeting this Friday on my work calendar?</p> <pre><code>event_name = EventName.resolve_from_text(\"a townhall meeting\")\n</code></pre>"},{"location":"reference/types/location/","title":"Location","text":""},{"location":"reference/types/location/#locationresolve_from_text","title":"<code>Location.resolve_from_text</code>","text":"<p>This API allows us to resolve a location from a given text.</p> <p>A text can also refer to multiple locations. For example, the text \"every drug store in my area\" should yield a list of <code>Location</code> objects.</p> <pre><code>Location.resolve_from_text(\ntext: str\n) : Location\n</code></pre> <p>Arguments</p> Name Type Optional Description <code>text</code> <code>str</code> No Textual decription of a location <p>Returns</p> Type Description <code>Location</code> <code>Location</code> object based on the <code>text</code> parameter to this function. <p>Example</p> <p>A <code>Location</code> can be an address, a city or a country name, or any publicly known place (for example, Times Square).</p> <p>If I leave now will I get to 37 Spring St by 12:30 pm?</p> <pre><code>location = Location.resolve_from_text(\"37 Spring St\")\n</code></pre> <p>A <code>Location</code> can be also be private to the user. It is in the API responsibility to infer a user specific location.</p> <p>Is it currently raining at home?</p> <pre><code>location = Location.resolve_from_text(\"at home\")\n</code></pre>"},{"location":"reference/types/location/#locationresolve_many_from_text","title":"<code>Location.resolve_many_from_text</code>","text":"<p>This API allows us to resolve multiple locations from a given text. For example, the text \"every drug store in my area\" should yield a list of <code>Location</code> objects.</p> <pre><code>Location.resolve_many_from_text(\ntext: str\n) : List[Location]\n</code></pre> <p>Arguments</p> Name Type Optional Description <code>text</code> <code>str</code> No Textual decription of a location <p>Returns</p> Type Description <code>List[Location]</code> A list of <code>Location</code> objects based on the <code>text</code> parameter to this function. <p>Example</p> <p>A <code>Location</code> can be an address, a city or a country name, or any publicly known place (for example, Times Square).</p> <p>If I leave now will I get to 37 Spring St by 12:30 pm?</p> <pre><code>location = Location.resolve_from_text(\"37 Spring St\")\n</code></pre> <p>A <code>Location</code> can be also be private to the user. It is in the API responsibility to infer a user specific location.</p> <p>Is it currently raining at home?</p> <pre><code>location = Location.resolve_from_text(\"at home\")\n</code></pre>"},{"location":"reference/types/location/#locationresolve_from_entity","title":"<code>Location.resolve_from_entity</code>","text":"<p>This API allows us to resolve a location from a given entity or list of entities, usually the result of a previous <code>resolve_from_text()</code> operation.</p> <pre><code>Content.resolve_from_entity(\nentity: Entity | List[Entity]\n) : Location | List[Location]\n</code></pre> <p>Arguments</p> Name Type Optional Description <code>entity</code> <code>Entity | List[Entity]</code> No An <code>Entity</code> object to be transformed to a <code>Location</code> <p>Returns</p> Type Description <code>Location | List[Location]</code> A location object or a list of <code>Location</code> objects based on the <code>text</code> parameter to this function. <p>Example</p> <p>A <code>Location</code> can be be inferred from different objects. One example may be a meeting location or an event venue.</p> <p>Directions to the Rockets game</p> <pre><code>event_name = EventName.resolve_from_text(\"the Rockets game\")\nevent = Event.find(event_name=event_name)\nlocation = Location.resolve_from_entity(event)\n...\n</code></pre>"},{"location":"reference/types/message_content_type/","title":"MessageContentType","text":""},{"location":"reference/types/message_content_type/#messagecontenttyperesolve_from_text","title":"<code>MessageContentType.resolve_from_text</code>","text":"<p>This API allows us to resolve the message type that should be sent. Commonly we may find the textual decription for message content type like \"audio\" or \"voice\" .</p> <p>It is possible that a user will specify a content type that should be interpreted as multiple content types. In that case, the API will return a list of <code>MessageContentType</code> objects.</p> <pre><code>MessageContentType.resolve_from_text(\ntext: str\n) : MessageContentType | List[MessageContentType]\n</code></pre> <p>Arguments</p> Name Type Optional Description <code>text</code> <code>str</code> No Textual <code>MessageContentType</code> description <p>Returns</p> Type Description <code>MessageContentType | List[MessageContentType]</code> <code>MessageContentType</code> object or a list of <code>MessageContentType</code> objects based on the <code>text</code> parameter to this function. <p>Example</p> <p>Sending a voice message requires the <code>MessageContentType</code> to be resolved.</p> <p>Send a voice message to Ted</p> <pre><code>message_content_type = MessageContentType.resolve_from_text(\"voice\")\n</code></pre>"},{"location":"reference/types/message_status/","title":"MessageStatus","text":""},{"location":"reference/types/message_status/#messagestatusresolve_from_text","title":"<code>MessageStatus.resolve_from_text</code>","text":"<p>This API allows us to resolve a message status from a user query. Statuses like \"new\", \"unread\" or \"seen\" for messages are common to be found and should be resolved. </p> <p>Take note that the return value from this function can be a list of <code>MessageStatus</code> objects, like in the case where the user command ask \"any message status\".</p> <pre><code>MessageStatus.resolve_from_text(\ntext: str\n) : MessageStatus | List[MessageStatus]\n</code></pre> <p>Arguments</p> Name Type Optional Description <code>text</code> <code>str</code> No Textual <code>MessageStatus</code> description <p>Returns</p> Type Description <code>MessageStatus | List[MessageStatus]</code> <code>MessageStatus</code> object or a list of <code>MessageStatus</code> objects based on the <code>text</code> parameter to this function. <p>Example</p> <p>A <code>MessageStatus</code> denote the message status \"read\" in a user command:</p> <p>Delete every seen message from Google to me.</p> <pre><code>message_status = MessageStatus.resolve_from_text(\"seen\")\n</code></pre>"},{"location":"reference/types/nav_road_condition/","title":"NavRoadCondition","text":""},{"location":"reference/types/nav_road_condition/#navroadconditionresolve_from_text","title":"<code>NavRoadCondition.resolve_from_text</code>","text":"<p>This API allows us to resolve a road condition out of navigation related queries.</p> <pre><code>NavRoadCondition.resolve_from_text(\ntext: str\n) : NavRoadCondition | List[NavRoadCondition]\n</code></pre> <p>Arguments</p> Name Type Optional Description <code>text</code> <code>str</code> No Textual NavRoadCondition description <p>Returns</p> Type Description <code>NavRoadCondition | List[NavRoadCondition]</code> <code>NavRoadCondition</code> object or a list of <code>NavRoadCondition</code> objects based on the <code>text</code> parameter to this function. <p>Example</p> <p>Get directions to downtown Detroit without flooding</p> <pre><code>nav_road_condition = NavRoadCondition.resolve_from_text(\"flooding\")\n</code></pre>"},{"location":"reference/types/nav_travel_method/","title":"NavTravelMethod","text":""},{"location":"reference/types/nav_travel_method/#navtravelmethodresolve_from_text","title":"<code>NavTravelMethod.resolve_from_text</code>","text":"<p>This API allows us to resolve a navigation method for travelling. Driving a car or riding a bicycle are both method of travel that can appear in a user command.</p> <pre><code>NavTravelMethod.resolve_from_text(\ntext: str\n) : NavTravelMethod | List[NavTravelMethod]\n</code></pre> <p>Arguments</p> Name Type Optional Description <code>text</code> <code>str</code> No Textual navigation travelling method description <p>Returns</p> Type Description <code>NavTravelMethod</code> <code>NavTravelMethod</code> object <p>Example</p> <p>how long is the road to SF on the PCH riding a bicycle</p> <pre><code>nav_travel_method = NavTravelMethod.resolve_from_text(\"riding a bicycle\")\n</code></pre>"},{"location":"reference/types/place_attribute/","title":"PlaceAttribute","text":""},{"location":"reference/types/place_attribute/#placeattributeresolve_from_text","title":"<code>PlaceAttribute.resolve_from_text</code>","text":"<p>This API allows us to resolve attributes of a place from a textual description. For example, whether a place is open or not including the openning hours of a place, or the stars review on it.</p> <p>Potentially, this API may result in a list of <code>PlaceAttributes</code></p> <pre><code>PlaceAttribute.resolve_from_text(\ntext: str\n) : PlaceAttribute | List[PlaceAttribute]\n</code></pre> <p>Arguments</p> Name Type Optional Description <code>text</code> <code>str</code> No Textual <code>PlaceAttribute</code> description <p>Returns</p> Type Description <code>PlaceAttribute</code> <code>PlaceAttribute</code> object or a list of <code>PlaceAttribute</code> objects based on the <code>text</code> parameter to this function. <p>Example</p> <p>A <code>PlaceAttribute</code> can be a specific app like Gmail</p> <p>Order 2 packages organic creamy peanut butter from WholeFood.</p> <pre><code>place_attribute = PlaceAttribute.resolve_from_text(\"open after midnight\")\n</code></pre>"},{"location":"reference/types/product/","title":"Product","text":""},{"location":"reference/types/product/#productresolve_from_text","title":"<code>Product.resolve_from_text</code>","text":"<p>This API allows us to resolve a product from a text. A product is not limited to the product category but can also include the product brand and manufacturer, For example, the text \"car insurance\", \"iPhone 14\", \"Detroit deep dish pizza\" or \"polka dot black dress\" should all be reolved in this API.</p> <p>It is possible that given a specific <code>text</code> input this API will infer it as a list of <code>Product</code> objects. For example, \"all The Hobbit trilogy books\" should results in a list of <code>Product</code> objects for each book in the bespoken trilogy.</p> <pre><code>Product.resolve_from_text(\ntext: str\n) : Product | List[Product]\n</code></pre> <p>Arguments</p> Name Type Optional Description <code>text</code> <code>str</code> No Textual <code>Product</code> description <p>Returns</p> Type Description <code>Product | List[Product]</code> <code>Product</code> object or a list of <code>Product</code> objects based on the <code>text</code> parameter to this function. <p>Example</p> <p>A <code>Product</code> can be include the product's brand, vendor, name and different features. Please note the price cmparison should be achieved using the <code>min</code> utility functions (see more in the Advanced Topics section).</p> <p>Where can I find a store cheapest price for the new Lego knights castle that has it in stock?</p> <pre><code>product = Product.resolve_from_text(\"the new Lego knights castle\")\n</code></pre>"},{"location":"reference/types/weather_attribute/","title":"WeatherAttribute","text":""},{"location":"reference/types/weather_attribute/#weatherattributeresolve_from_text","title":"<code>WeatherAttribute.resolve_from_text</code>","text":"<p>This API allows us to resolve a weather attribute or condition from a user input. For example, \"stormy\", \"rain\" or \"cold\" are all weather attributes.</p> <pre><code>WeatherAttribute.resolve_from_text(\ntext: str\n) : WeatherAttribute\n</code></pre> <p>Note</p> <p>Weather tempreature unit is represented by <code>WeatherTemperatureUnit</code> and is not a weather attribute.</p> <p>Arguments</p> Name Type Optional Description <code>text</code> <code>str</code> No Textual WeatherAttribute description <p>Returns</p> Type Description <code>WeatherAttribute</code> <code>WeatherAttribute</code> object based on the <code>text</code> parameter to this function. <p>Example</p> <p>A <code>WeatherAttribute</code> denotes the weather attribute \"sunny\" in a user command:</p> <p>Will it be sunny with clear skies this weekend?</p> <pre><code>weather_attribute = WeatherAttribute.resolve_from_text(\"sunny with clear skies\")\n</code></pre>"},{"location":"reference/types/weather_attribute/#weatherattributeresolve_many_from_text","title":"<code>WeatherAttribute.resolve_many_from_text</code>","text":"<p>This API can possibly return a list of <code>WeatherAttribute</code> objects given a text input that expresses multiple weather attributes. For example, \"any winter weather\".</p> <pre><code>WeatherAttribute.resolve_from_text(\ntext: str\n) : List[WeatherAttribute]\n</code></pre> <p>Arguments</p> Name Type Optional Description <code>text</code> <code>str</code> No Textual WeatherAttribute description <p>Returns</p> Type Description <code>List[WeatherAttribute]</code> A list of <code>WeatherAttribute</code> objects based on the <code>text</code> parameter to this function. <p>Example</p> <p>Are we looking into any non rainy day this week?</p> <pre><code>weather_attributes = WeatherAttribute.resolve_many_from_text(\"any non rainy day\")\n</code></pre>"},{"location":"reference/types/weather_temperature_unit/","title":"WeatherTemperatureUnit","text":""},{"location":"reference/types/weather_temperature_unit/#weathertemperatureunitresolve_from_text","title":"<code>WeatherTemperatureUnit.resolve_from_text</code>","text":"<p>This API allows us to resolve a requested temperature unit (like celsius or fahrenheit).</p> <p>Despite the fact that this function may return <code>WeatherTemperatureUnit</code> it is highly unlikely to find an example where a list would be returned.</p> <pre><code>WeatherTemperatureUnit.resolve_from_text(\ntext: str\n) : WeatherTemperatureUnit : List[WeatherTemperatureUnit]\n</code></pre> <p>Note</p> <p>Weather tempreature unit is represented by <code>WeatherTemperatureUnit</code> and is not a weather attribute.</p> <p>Arguments</p> Name Type Optional Description <code>text</code> <code>str</code> No Textual WeatherTemperatureUnit description <p>Returns</p> Type Description <code>WeatherTemperatureUnit | List[WeatherTemperatureUnit]</code> <code>WeatherTemperatureUnit</code> object or a list of <code>WeatherTemperatureUnit</code> objects based on the <code>text</code> parameter to this function. <p>Example</p> <p>A <code>WeatherTemperatureUnit</code> denote the weather attribute \"sunny\" in a user command:</p> <p>Tell me the weather in fahrenheit.</p> <pre><code>weather_temperature_unit = WeatherTemperatureUnit.resolve_from_text(\"fahrenheit\")\n</code></pre>"}]}